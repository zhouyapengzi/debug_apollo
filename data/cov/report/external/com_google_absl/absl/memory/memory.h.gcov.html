<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - stripped_conv.info - external/com_google_absl/absl/memory/memory.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">external/com_google_absl/absl/memory</a> - memory.h<span style="font-size: 80%;"> (source / <a href="memory.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">stripped_conv.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntryHi">100.0 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2020-05-21 16:34:32</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">2</td>
            <td class="headerCovTableEntry">5</td>
            <td class="headerCovTableEntryLo">40.0 %</td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td></td>
            <td class="headerItem">Branches:</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntryLo">40.0 %</td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">           Branch data     Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>                :            : // Copyright 2017 The Abseil Authors.</a>
<span class="lineNum">       2 </span>                :            : //
<span class="lineNum">       3 </span>                :            : // Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<span class="lineNum">       4 </span>                :            : // you may not use this file except in compliance with the License.
<span class="lineNum">       5 </span>                :            : // You may obtain a copy of the License at
<span class="lineNum">       6 </span>                :            : //
<span class="lineNum">       7 </span>                :            : //      http://www.apache.org/licenses/LICENSE-2.0
<span class="lineNum">       8 </span>                :            : //
<span class="lineNum">       9 </span>                :            : // Unless required by applicable law or agreed to in writing, software
<span class="lineNum">      10 </span>                :            : // distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<span class="lineNum">      11 </span>                :            : // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<span class="lineNum">      12 </span>                :            : // See the License for the specific language governing permissions and
<span class="lineNum">      13 </span>                :            : // limitations under the License.
<span class="lineNum">      14 </span>                :            : //
<span class="lineNum">      15 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">      16 </span>                :            : // File: memory.h
<span class="lineNum">      17 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">      18 </span>                :            : //
<span class="lineNum">      19 </span>                :            : // This header file contains utility functions for managing the creation and
<span class="lineNum">      20 </span>                :            : // conversion of smart pointers. This file is an extension to the C++
<span class="lineNum">      21 </span>                :            : // standard &lt;memory&gt; library header file.
<span class="lineNum">      22 </span>                :            : 
<span class="lineNum">      23 </span>                :            : #ifndef ABSL_MEMORY_MEMORY_H_
<span class="lineNum">      24 </span>                :            : #define ABSL_MEMORY_MEMORY_H_
<span class="lineNum">      25 </span>                :            : 
<span class="lineNum">      26 </span>                :            : #include &lt;cstddef&gt;
<span class="lineNum">      27 </span>                :            : #include &lt;limits&gt;
<span class="lineNum">      28 </span>                :            : #include &lt;memory&gt;
<span class="lineNum">      29 </span>                :            : #include &lt;new&gt;
<span class="lineNum">      30 </span>                :            : #include &lt;type_traits&gt;
<span class="lineNum">      31 </span>                :            : #include &lt;utility&gt;
<span class="lineNum">      32 </span>                :            : 
<span class="lineNum">      33 </span>                :            : #include &quot;absl/base/macros.h&quot;
<span class="lineNum">      34 </span>                :            : #include &quot;absl/meta/type_traits.h&quot;
<span class="lineNum">      35 </span>                :            : 
<span class="lineNum">      36 </span>                :            : namespace absl {
<span class="lineNum">      37 </span>                :            : 
<span class="lineNum">      38 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">      39 </span>                :            : // Function Template: WrapUnique()
<span class="lineNum">      40 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">      41 </span>                :            : //
<span class="lineNum">      42 </span>                :            : //  Adopts ownership from a raw pointer and transfers it to the returned
<span class="lineNum">      43 </span>                :            : //  `std::unique_ptr`, whose type is deduced.
<span class="lineNum">      44 </span>                :            : //
<span class="lineNum">      45 </span>                :            : // Example:
<span class="lineNum">      46 </span>                :            : //   X* NewX(int, int);
<span class="lineNum">      47 </span>                :            : //   auto x = WrapUnique(NewX(1, 2));  // 'x' is std::unique_ptr&lt;X&gt;.
<span class="lineNum">      48 </span>                :            : //
<span class="lineNum">      49 </span>                :            : // `absl::WrapUnique` is useful for capturing the output of a raw pointer
<span class="lineNum">      50 </span>                :            : // factory. However, prefer 'absl::make_unique&lt;T&gt;(args...) over
<span class="lineNum">      51 </span>                :            : // 'absl::WrapUnique(new T(args...))'.
<span class="lineNum">      52 </span>                :            : //
<span class="lineNum">      53 </span>                :            : //   auto x = WrapUnique(new X(1, 2));  // works, but nonideal.
<span class="lineNum">      54 </span>                :            : //   auto x = make_unique&lt;X&gt;(1, 2);     // safer, standard, avoids raw 'new'.
<span class="lineNum">      55 </span>                :            : //
<span class="lineNum">      56 </span>                :            : // Note that `absl::WrapUnique(p)` is valid only if `delete p` is a valid
<span class="lineNum">      57 </span>                :            : // expression. In particular, `absl::WrapUnique()` cannot wrap pointers to
<span class="lineNum">      58 </span>                :            : // arrays, functions or void, and it must not be used to capture pointers
<span class="lineNum">      59 </span>                :            : // obtained from array-new expressions (even though that would compile!).
<span class="lineNum">      60 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">      61 </span>                :            : std::unique_ptr&lt;T&gt; WrapUnique(T* ptr) {
<span class="lineNum">      62 </span>                :            :   static_assert(!std::is_array&lt;T&gt;::value, &quot;array types are unsupported&quot;);
<span class="lineNum">      63 </span>                :            :   static_assert(std::is_object&lt;T&gt;::value, &quot;non-object types are unsupported&quot;);
<span class="lineNum">      64 </span>                :            :   return std::unique_ptr&lt;T&gt;(ptr);
<span class="lineNum">      65 </span>                :            : }
<span class="lineNum">      66 </span>                :            : 
<span class="lineNum">      67 </span>                :            : namespace memory_internal {
<span class="lineNum">      68 </span>                :            : 
<span class="lineNum">      69 </span>                :            : // Traits to select proper overload and return type for `absl::make_unique&lt;&gt;`.
<span class="lineNum">      70 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">      71 </span>                :            : struct MakeUniqueResult {
<span class="lineNum">      72 </span>                :            :   using scalar = std::unique_ptr&lt;T&gt;;
<span class="lineNum">      73 </span>                :            : };
<span class="lineNum">      74 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">      75 </span>                :            : struct MakeUniqueResult&lt;T[]&gt; {
<span class="lineNum">      76 </span>                :            :   using array = std::unique_ptr&lt;T[]&gt;;
<span class="lineNum">      77 </span>                :            : };
<span class="lineNum">      78 </span>                :            : template &lt;typename T, size_t N&gt;
<span class="lineNum">      79 </span>                :            : struct MakeUniqueResult&lt;T[N]&gt; {
<span class="lineNum">      80 </span>                :            :   using invalid = void;
<span class="lineNum">      81 </span>                :            : };
<span class="lineNum">      82 </span>                :            : 
<span class="lineNum">      83 </span>                :            : }  // namespace memory_internal
<span class="lineNum">      84 </span>                :            : 
<span class="lineNum">      85 </span>                :            : #if __cplusplus &gt;= 201402L || defined(_MSC_VER)
<span class="lineNum">      86 </span>                :            : using std::make_unique;
<span class="lineNum">      87 </span>                :            : #else
<span class="lineNum">      88 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">      89 </span>                :            : // Function Template: make_unique&lt;T&gt;()
<span class="lineNum">      90 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">      91 </span>                :            : //
<span class="lineNum">      92 </span>                :            : // Creates a `std::unique_ptr&lt;&gt;`, while avoiding issues creating temporaries
<span class="lineNum">      93 </span>                :            : // during the construction process. `absl::make_unique&lt;&gt;` also avoids redundant
<span class="lineNum">      94 </span>                :            : // type declarations, by avoiding the need to explicitly use the `new` operator.
<span class="lineNum">      95 </span>                :            : //
<span class="lineNum">      96 </span>                :            : // This implementation of `absl::make_unique&lt;&gt;` is designed for C++11 code and
<span class="lineNum">      97 </span>                :            : // will be replaced in C++14 by the equivalent `std::make_unique&lt;&gt;` abstraction.
<span class="lineNum">      98 </span>                :            : // `absl::make_unique&lt;&gt;` is designed to be 100% compatible with
<span class="lineNum">      99 </span>                :            : // `std::make_unique&lt;&gt;` so that the eventual migration will involve a simple
<span class="lineNum">     100 </span>                :            : // rename operation.
<span class="lineNum">     101 </span>                :            : //
<span class="lineNum">     102 </span>                :            : // For more background on why `std::unique_ptr&lt;T&gt;(new T(a,b))` is problematic,
<span class="lineNum">     103 </span>                :            : // see Herb Sutter's explanation on
<span class="lineNum">     104 </span>                :            : // (Exception-Safe Function Calls)[http://herbsutter.com/gotw/_102/].
<span class="lineNum">     105 </span>                :            : // (In general, reviewers should treat `new T(a,b)` with scrutiny.)
<span class="lineNum">     106 </span>                :            : //
<span class="lineNum">     107 </span>                :            : // Example usage:
<span class="lineNum">     108 </span>                :            : //
<span class="lineNum">     109 </span>                :            : //    auto p = make_unique&lt;X&gt;(args...);  // 'p'  is a std::unique_ptr&lt;X&gt;
<span class="lineNum">     110 </span>                :            : //    auto pa = make_unique&lt;X[]&gt;(5);     // 'pa' is a std::unique_ptr&lt;X[]&gt;
<span class="lineNum">     111 </span>                :            : //
<span class="lineNum">     112 </span>                :            : // Three overloads of `absl::make_unique` are required:
<span class="lineNum">     113 </span>                :            : //
<span class="lineNum">     114 </span>                :            : //   - For non-array T:
<span class="lineNum">     115 </span>                :            : //
<span class="lineNum">     116 </span>                :            : //       Allocates a T with `new T(std::forward&lt;Args&gt; args...)`,
<span class="lineNum">     117 </span>                :            : //       forwarding all `args` to T's constructor.
<span class="lineNum">     118 </span>                :            : //       Returns a `std::unique_ptr&lt;T&gt;` owning that object.
<span class="lineNum">     119 </span>                :            : //
<span class="lineNum">     120 </span>                :            : //   - For an array of unknown bounds T[]:
<span class="lineNum">     121 </span>                :            : //
<span class="lineNum">     122 </span>                :            : //       `absl::make_unique&lt;&gt;` will allocate an array T of type U[] with
<span class="lineNum">     123 </span>                :            : //       `new U[n]()` and return a `std::unique_ptr&lt;U[]&gt;` owning that array.
<span class="lineNum">     124 </span>                :            : //
<span class="lineNum">     125 </span>                :            : //       Note that 'U[n]()' is different from 'U[n]', and elements will be
<span class="lineNum">     126 </span>                :            : //       value-initialized. Note as well that `std::unique_ptr` will perform its
<span class="lineNum">     127 </span>                :            : //       own destruction of the array elements upon leaving scope, even though
<span class="lineNum">     128 </span>                :            : //       the array [] does not have a default destructor.
<span class="lineNum">     129 </span>                :            : //
<span class="lineNum">     130 </span>                :            : //       NOTE: an array of unknown bounds T[] may still be (and often will be)
<span class="lineNum">     131 </span>                :            : //       initialized to have a size, and will still use this overload. E.g:
<span class="lineNum">     132 </span>                :            : //
<span class="lineNum">     133 </span>                :            : //         auto my_array = absl::make_unique&lt;int[]&gt;(10);
<span class="lineNum">     134 </span>                :            : //
<span class="lineNum">     135 </span>                :            : //   - For an array of known bounds T[N]:
<span class="lineNum">     136 </span>                :            : //
<span class="lineNum">     137 </span>                :            : //       `absl::make_unique&lt;&gt;` is deleted (like with `std::make_unique&lt;&gt;`) as
<span class="lineNum">     138 </span>                :            : //       this overload is not useful.
<span class="lineNum">     139 </span>                :            : //
<span class="lineNum">     140 </span>                :            : //       NOTE: an array of known bounds T[N] is not considered a useful
<span class="lineNum">     141 </span>                :            : //       construction, and may cause undefined behavior in templates. E.g:
<span class="lineNum">     142 </span>                :            : //
<span class="lineNum">     143 </span>                :            : //         auto my_array = absl::make_unique&lt;int[10]&gt;();
<span class="lineNum">     144 </span>                :            : //
<span class="lineNum">     145 </span>                :            : //       In those cases, of course, you can still use the overload above and
<span class="lineNum">     146 </span>                :            : //       simply initialize it to its desired size:
<span class="lineNum">     147 </span>                :            : //
<span class="lineNum">     148 </span>                :            : //         auto my_array = absl::make_unique&lt;int[]&gt;(10);
<span class="lineNum">     149 </span>                :            : 
<a name="150"><span class="lineNum">     150 </span>                :            : // `absl::make_unique` overload for non-array types.</a>
<span class="lineNum">     151 </span>                :            : template &lt;typename T, typename... Args&gt;
<span class="lineNum">     152 </span>                :<span class="lineCov">          7 : typename memory_internal::MakeUniqueResult&lt;T&gt;::scalar make_unique(</span>
<span class="lineNum">     153 </span>                :            :     Args&amp;&amp;... args) {
<span class="lineNum">     154 </span>[<span class="branchCov" title="Branch 3 was taken 1 time"> + </span><span class="branchNoCov" title="Branch 4 was not taken"> - </span>][<span class="branchCov" title="Branch 6 was taken 1 time"> + </span><span class="branchNoCov" title="Branch 7 was not taken"> - </span>]:<span class="lineCov">          7 :   return std::unique_ptr&lt;T&gt;(new T(std::forward&lt;Args&gt;(args)...));</span>
<span class="lineNum">         </span>[<span class="branchCov" title="Branch 15 was taken 6 times"> + </span><span class="branchNoCov" title="Branch 16 was not taken"> - </span>][<span class="branchCov" title="Branch 18 was taken 6 times"> + </span><span class="branchNoCov" title="Branch 19 was not taken"> - </span>]
<span class="lineNum">         </span>        [<span class="branchNoExec" title="Branch 11 was not executed"> # </span><span class="branchNoExec" title="Branch 12 was not executed"> # </span>]
<span class="lineNum">     155 </span>                :            : }
<span class="lineNum">     156 </span>                :            : 
<span class="lineNum">     157 </span>                :            : // `absl::make_unique` overload for an array T[] of unknown bounds.
<span class="lineNum">     158 </span>                :            : // The array allocation needs to use the `new T[size]` form and cannot take
<span class="lineNum">     159 </span>                :            : // element constructor arguments. The `std::unique_ptr` will manage destructing
<span class="lineNum">     160 </span>                :            : // these array elements.
<span class="lineNum">     161 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     162 </span>                :            : typename memory_internal::MakeUniqueResult&lt;T&gt;::array make_unique(size_t n) {
<span class="lineNum">     163 </span>                :            :   return std::unique_ptr&lt;T&gt;(new typename absl::remove_extent_t&lt;T&gt;[n]());
<span class="lineNum">     164 </span>                :            : }
<span class="lineNum">     165 </span>                :            : 
<span class="lineNum">     166 </span>                :            : // `absl::make_unique` overload for an array T[N] of known bounds.
<span class="lineNum">     167 </span>                :            : // This construction will be rejected.
<span class="lineNum">     168 </span>                :            : template &lt;typename T, typename... Args&gt;
<span class="lineNum">     169 </span>                :            : typename memory_internal::MakeUniqueResult&lt;T&gt;::invalid make_unique(
<span class="lineNum">     170 </span>                :            :     Args&amp;&amp;... /* args */) = delete;
<span class="lineNum">     171 </span>                :            : #endif
<span class="lineNum">     172 </span>                :            : 
<span class="lineNum">     173 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">     174 </span>                :            : // Function Template: RawPtr()
<span class="lineNum">     175 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">     176 </span>                :            : //
<span class="lineNum">     177 </span>                :            : // Extracts the raw pointer from a pointer-like value `ptr`. `absl::RawPtr` is
<span class="lineNum">     178 </span>                :            : // useful within templates that need to handle a complement of raw pointers,
<span class="lineNum">     179 </span>                :            : // `std::nullptr_t`, and smart pointers.
<span class="lineNum">     180 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     181 </span>                :            : auto RawPtr(T&amp;&amp; ptr) -&gt; decltype(&amp;*ptr) {
<span class="lineNum">     182 </span>                :            :   // ptr is a forwarding reference to support Ts with non-const operators.
<span class="lineNum">     183 </span>                :            :   return (ptr != nullptr) ? &amp;*ptr : nullptr;
<span class="lineNum">     184 </span>                :            : }
<span class="lineNum">     185 </span>                :            : inline std::nullptr_t RawPtr(std::nullptr_t) { return nullptr; }
<span class="lineNum">     186 </span>                :            : 
<span class="lineNum">     187 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">     188 </span>                :            : // Function Template: ShareUniquePtr()
<span class="lineNum">     189 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">     190 </span>                :            : //
<span class="lineNum">     191 </span>                :            : // Adopts a `std::unique_ptr` rvalue and returns a `std::shared_ptr` of deduced
<span class="lineNum">     192 </span>                :            : // type. Ownership (if any) of the held value is transferred to the returned
<span class="lineNum">     193 </span>                :            : // shared pointer.
<span class="lineNum">     194 </span>                :            : //
<span class="lineNum">     195 </span>                :            : // Example:
<span class="lineNum">     196 </span>                :            : //
<span class="lineNum">     197 </span>                :            : //     auto up = absl::make_unique&lt;int&gt;(10);
<span class="lineNum">     198 </span>                :            : //     auto sp = absl::ShareUniquePtr(std::move(up));  // shared_ptr&lt;int&gt;
<span class="lineNum">     199 </span>                :            : //     CHECK_EQ(*sp, 10);
<span class="lineNum">     200 </span>                :            : //     CHECK(up == nullptr);
<span class="lineNum">     201 </span>                :            : //
<span class="lineNum">     202 </span>                :            : // Note that this conversion is correct even when T is an array type, and more
<span class="lineNum">     203 </span>                :            : // generally it works for *any* deleter of the `unique_ptr` (single-object
<span class="lineNum">     204 </span>                :            : // deleter, array deleter, or any custom deleter), since the deleter is adopted
<span class="lineNum">     205 </span>                :            : // by the shared pointer as well. The deleter is copied (unless it is a
<span class="lineNum">     206 </span>                :            : // reference).
<span class="lineNum">     207 </span>                :            : //
<span class="lineNum">     208 </span>                :            : // Implements the resolution of [LWG 2415](http://wg21.link/lwg2415), by which a
<span class="lineNum">     209 </span>                :            : // null shared pointer does not attempt to call the deleter.
<span class="lineNum">     210 </span>                :            : template &lt;typename T, typename D&gt;
<span class="lineNum">     211 </span>                :            : std::shared_ptr&lt;T&gt; ShareUniquePtr(std::unique_ptr&lt;T, D&gt;&amp;&amp; ptr) {
<span class="lineNum">     212 </span>                :            :   return ptr ? std::shared_ptr&lt;T&gt;(std::move(ptr)) : std::shared_ptr&lt;T&gt;();
<span class="lineNum">     213 </span>                :            : }
<span class="lineNum">     214 </span>                :            : 
<span class="lineNum">     215 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">     216 </span>                :            : // Function Template: WeakenPtr()
<span class="lineNum">     217 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">     218 </span>                :            : //
<span class="lineNum">     219 </span>                :            : // Creates a weak pointer associated with a given shared pointer. The returned
<span class="lineNum">     220 </span>                :            : // value is a `std::weak_ptr` of deduced type.
<span class="lineNum">     221 </span>                :            : //
<span class="lineNum">     222 </span>                :            : // Example:
<span class="lineNum">     223 </span>                :            : //
<span class="lineNum">     224 </span>                :            : //    auto sp = std::make_shared&lt;int&gt;(10);
<span class="lineNum">     225 </span>                :            : //    auto wp = absl::WeakenPtr(sp);
<span class="lineNum">     226 </span>                :            : //    CHECK_EQ(sp.get(), wp.lock().get());
<span class="lineNum">     227 </span>                :            : //    sp.reset();
<span class="lineNum">     228 </span>                :            : //    CHECK(wp.lock() == nullptr);
<span class="lineNum">     229 </span>                :            : //
<span class="lineNum">     230 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     231 </span>                :            : std::weak_ptr&lt;T&gt; WeakenPtr(const std::shared_ptr&lt;T&gt;&amp; ptr) {
<span class="lineNum">     232 </span>                :            :   return std::weak_ptr&lt;T&gt;(ptr);
<span class="lineNum">     233 </span>                :            : }
<span class="lineNum">     234 </span>                :            : 
<span class="lineNum">     235 </span>                :            : namespace memory_internal {
<span class="lineNum">     236 </span>                :            : 
<span class="lineNum">     237 </span>                :            : // ExtractOr&lt;E, O, D&gt;::type evaluates to E&lt;O&gt; if possible. Otherwise, D.
<span class="lineNum">     238 </span>                :            : template &lt;template &lt;typename&gt; class Extract, typename Obj, typename Default,
<span class="lineNum">     239 </span>                :            :           typename&gt;
<span class="lineNum">     240 </span>                :            : struct ExtractOr {
<span class="lineNum">     241 </span>                :            :   using type = Default;
<span class="lineNum">     242 </span>                :            : };
<span class="lineNum">     243 </span>                :            : 
<span class="lineNum">     244 </span>                :            : template &lt;template &lt;typename&gt; class Extract, typename Obj, typename Default&gt;
<span class="lineNum">     245 </span>                :            : struct ExtractOr&lt;Extract, Obj, Default, void_t&lt;Extract&lt;Obj&gt;&gt;&gt; {
<span class="lineNum">     246 </span>                :            :   using type = Extract&lt;Obj&gt;;
<span class="lineNum">     247 </span>                :            : };
<span class="lineNum">     248 </span>                :            : 
<span class="lineNum">     249 </span>                :            : template &lt;template &lt;typename&gt; class Extract, typename Obj, typename Default&gt;
<span class="lineNum">     250 </span>                :            : using ExtractOrT = typename ExtractOr&lt;Extract, Obj, Default, void&gt;::type;
<span class="lineNum">     251 </span>                :            : 
<span class="lineNum">     252 </span>                :            : // Extractors for the features of allocators.
<span class="lineNum">     253 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     254 </span>                :            : using GetPointer = typename T::pointer;
<span class="lineNum">     255 </span>                :            : 
<span class="lineNum">     256 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     257 </span>                :            : using GetConstPointer = typename T::const_pointer;
<span class="lineNum">     258 </span>                :            : 
<span class="lineNum">     259 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     260 </span>                :            : using GetVoidPointer = typename T::void_pointer;
<span class="lineNum">     261 </span>                :            : 
<span class="lineNum">     262 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     263 </span>                :            : using GetConstVoidPointer = typename T::const_void_pointer;
<span class="lineNum">     264 </span>                :            : 
<span class="lineNum">     265 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     266 </span>                :            : using GetDifferenceType = typename T::difference_type;
<span class="lineNum">     267 </span>                :            : 
<span class="lineNum">     268 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     269 </span>                :            : using GetSizeType = typename T::size_type;
<span class="lineNum">     270 </span>                :            : 
<span class="lineNum">     271 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     272 </span>                :            : using GetPropagateOnContainerCopyAssignment =
<span class="lineNum">     273 </span>                :            :     typename T::propagate_on_container_copy_assignment;
<span class="lineNum">     274 </span>                :            : 
<span class="lineNum">     275 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     276 </span>                :            : using GetPropagateOnContainerMoveAssignment =
<span class="lineNum">     277 </span>                :            :     typename T::propagate_on_container_move_assignment;
<span class="lineNum">     278 </span>                :            : 
<span class="lineNum">     279 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     280 </span>                :            : using GetPropagateOnContainerSwap = typename T::propagate_on_container_swap;
<span class="lineNum">     281 </span>                :            : 
<span class="lineNum">     282 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     283 </span>                :            : using GetIsAlwaysEqual = typename T::is_always_equal;
<span class="lineNum">     284 </span>                :            : 
<span class="lineNum">     285 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     286 </span>                :            : struct GetFirstArg;
<span class="lineNum">     287 </span>                :            : 
<span class="lineNum">     288 </span>                :            : template &lt;template &lt;typename...&gt; class Class, typename T, typename... Args&gt;
<span class="lineNum">     289 </span>                :            : struct GetFirstArg&lt;Class&lt;T, Args...&gt;&gt; {
<span class="lineNum">     290 </span>                :            :   using type = T;
<span class="lineNum">     291 </span>                :            : };
<span class="lineNum">     292 </span>                :            : 
<span class="lineNum">     293 </span>                :            : template &lt;typename Ptr, typename = void&gt;
<span class="lineNum">     294 </span>                :            : struct ElementType {
<span class="lineNum">     295 </span>                :            :   using type = typename GetFirstArg&lt;Ptr&gt;::type;
<span class="lineNum">     296 </span>                :            : };
<span class="lineNum">     297 </span>                :            : 
<span class="lineNum">     298 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     299 </span>                :            : struct ElementType&lt;T, void_t&lt;typename T::element_type&gt;&gt; {
<span class="lineNum">     300 </span>                :            :   using type = typename T::element_type;
<span class="lineNum">     301 </span>                :            : };
<span class="lineNum">     302 </span>                :            : 
<span class="lineNum">     303 </span>                :            : template &lt;typename T, typename U&gt;
<span class="lineNum">     304 </span>                :            : struct RebindFirstArg;
<span class="lineNum">     305 </span>                :            : 
<span class="lineNum">     306 </span>                :            : template &lt;template &lt;typename...&gt; class Class, typename T, typename... Args,
<span class="lineNum">     307 </span>                :            :           typename U&gt;
<span class="lineNum">     308 </span>                :            : struct RebindFirstArg&lt;Class&lt;T, Args...&gt;, U&gt; {
<span class="lineNum">     309 </span>                :            :   using type = Class&lt;U, Args...&gt;;
<span class="lineNum">     310 </span>                :            : };
<span class="lineNum">     311 </span>                :            : 
<span class="lineNum">     312 </span>                :            : template &lt;typename T, typename U, typename = void&gt;
<span class="lineNum">     313 </span>                :            : struct RebindPtr {
<span class="lineNum">     314 </span>                :            :   using type = typename RebindFirstArg&lt;T, U&gt;::type;
<span class="lineNum">     315 </span>                :            : };
<span class="lineNum">     316 </span>                :            : 
<span class="lineNum">     317 </span>                :            : template &lt;typename T, typename U&gt;
<span class="lineNum">     318 </span>                :            : struct RebindPtr&lt;T, U, void_t&lt;typename T::template rebind&lt;U&gt;&gt;&gt; {
<span class="lineNum">     319 </span>                :            :   using type = typename T::template rebind&lt;U&gt;;
<span class="lineNum">     320 </span>                :            : };
<span class="lineNum">     321 </span>                :            : 
<span class="lineNum">     322 </span>                :            : template &lt;typename T, typename U&gt;
<span class="lineNum">     323 </span>                :            : constexpr bool HasRebindAlloc(...) {
<span class="lineNum">     324 </span>                :            :   return false;
<span class="lineNum">     325 </span>                :            : }
<span class="lineNum">     326 </span>                :            : 
<span class="lineNum">     327 </span>                :            : template &lt;typename T, typename U&gt;
<span class="lineNum">     328 </span>                :            : constexpr bool HasRebindAlloc(typename T::template rebind&lt;U&gt;::other*) {
<span class="lineNum">     329 </span>                :            :   return true;
<span class="lineNum">     330 </span>                :            : }
<span class="lineNum">     331 </span>                :            : 
<span class="lineNum">     332 </span>                :            : template &lt;typename T, typename U, bool = HasRebindAlloc&lt;T, U&gt;(nullptr)&gt;
<span class="lineNum">     333 </span>                :            : struct RebindAlloc {
<span class="lineNum">     334 </span>                :            :   using type = typename RebindFirstArg&lt;T, U&gt;::type;
<span class="lineNum">     335 </span>                :            : };
<span class="lineNum">     336 </span>                :            : 
<span class="lineNum">     337 </span>                :            : template &lt;typename T, typename U&gt;
<span class="lineNum">     338 </span>                :            : struct RebindAlloc&lt;T, U, true&gt; {
<span class="lineNum">     339 </span>                :            :   using type = typename T::template rebind&lt;U&gt;::other;
<span class="lineNum">     340 </span>                :            : };
<span class="lineNum">     341 </span>                :            : 
<span class="lineNum">     342 </span>                :            : }  // namespace memory_internal
<span class="lineNum">     343 </span>                :            : 
<span class="lineNum">     344 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">     345 </span>                :            : // Class Template: pointer_traits
<span class="lineNum">     346 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">     347 </span>                :            : //
<span class="lineNum">     348 </span>                :            : // An implementation of C++11's std::pointer_traits.
<span class="lineNum">     349 </span>                :            : //
<span class="lineNum">     350 </span>                :            : // Provided for portability on toolchains that have a working C++11 compiler,
<span class="lineNum">     351 </span>                :            : // but the standard library is lacking in C++11 support. For example, some
<span class="lineNum">     352 </span>                :            : // version of the Android NDK.
<span class="lineNum">     353 </span>                :            : //
<span class="lineNum">     354 </span>                :            : 
<span class="lineNum">     355 </span>                :            : template &lt;typename Ptr&gt;
<span class="lineNum">     356 </span>                :            : struct pointer_traits {
<span class="lineNum">     357 </span>                :            :   using pointer = Ptr;
<span class="lineNum">     358 </span>                :            : 
<span class="lineNum">     359 </span>                :            :   // element_type:
<span class="lineNum">     360 </span>                :            :   // Ptr::element_type if present. Otherwise T if Ptr is a template
<span class="lineNum">     361 </span>                :            :   // instantiation Template&lt;T, Args...&gt;
<span class="lineNum">     362 </span>                :            :   using element_type = typename memory_internal::ElementType&lt;Ptr&gt;::type;
<span class="lineNum">     363 </span>                :            : 
<span class="lineNum">     364 </span>                :            :   // difference_type:
<span class="lineNum">     365 </span>                :            :   // Ptr::difference_type if present, otherwise std::ptrdiff_t
<span class="lineNum">     366 </span>                :            :   using difference_type =
<span class="lineNum">     367 </span>                :            :       memory_internal::ExtractOrT&lt;memory_internal::GetDifferenceType, Ptr,
<span class="lineNum">     368 </span>                :            :                                   std::ptrdiff_t&gt;;
<span class="lineNum">     369 </span>                :            : 
<span class="lineNum">     370 </span>                :            :   // rebind:
<span class="lineNum">     371 </span>                :            :   // Ptr::rebind&lt;U&gt; if exists, otherwise Template&lt;U, Args...&gt; if Ptr is a
<span class="lineNum">     372 </span>                :            :   // template instantiation Template&lt;T, Args...&gt;
<span class="lineNum">     373 </span>                :            :   template &lt;typename U&gt;
<span class="lineNum">     374 </span>                :            :   using rebind = typename memory_internal::RebindPtr&lt;Ptr, U&gt;::type;
<span class="lineNum">     375 </span>                :            : 
<span class="lineNum">     376 </span>                :            :   // pointer_to:
<span class="lineNum">     377 </span>                :            :   // Calls Ptr::pointer_to(r)
<span class="lineNum">     378 </span>                :            :   static pointer pointer_to(element_type&amp; r) {  // NOLINT(runtime/references)
<span class="lineNum">     379 </span>                :            :     return Ptr::pointer_to(r);
<span class="lineNum">     380 </span>                :            :   }
<span class="lineNum">     381 </span>                :            : };
<span class="lineNum">     382 </span>                :            : 
<span class="lineNum">     383 </span>                :            : // Specialization for T*.
<span class="lineNum">     384 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     385 </span>                :            : struct pointer_traits&lt;T*&gt; {
<span class="lineNum">     386 </span>                :            :   using pointer = T*;
<span class="lineNum">     387 </span>                :            :   using element_type = T;
<span class="lineNum">     388 </span>                :            :   using difference_type = std::ptrdiff_t;
<span class="lineNum">     389 </span>                :            : 
<span class="lineNum">     390 </span>                :            :   template &lt;typename U&gt;
<span class="lineNum">     391 </span>                :            :   using rebind = U*;
<span class="lineNum">     392 </span>                :            : 
<span class="lineNum">     393 </span>                :            :   // pointer_to:
<span class="lineNum">     394 </span>                :            :   // Calls std::addressof(r)
<span class="lineNum">     395 </span>                :            :   static pointer pointer_to(
<span class="lineNum">     396 </span>                :            :       element_type&amp; r) noexcept {  // NOLINT(runtime/references)
<span class="lineNum">     397 </span>                :            :     return std::addressof(r);
<span class="lineNum">     398 </span>                :            :   }
<span class="lineNum">     399 </span>                :            : };
<span class="lineNum">     400 </span>                :            : 
<span class="lineNum">     401 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">     402 </span>                :            : // Class Template: allocator_traits
<span class="lineNum">     403 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">     404 </span>                :            : //
<span class="lineNum">     405 </span>                :            : // A C++11 compatible implementation of C++17's std::allocator_traits.
<span class="lineNum">     406 </span>                :            : //
<span class="lineNum">     407 </span>                :            : template &lt;typename Alloc&gt;
<span class="lineNum">     408 </span>                :            : struct allocator_traits {
<span class="lineNum">     409 </span>                :            :   using allocator_type = Alloc;
<span class="lineNum">     410 </span>                :            : 
<span class="lineNum">     411 </span>                :            :   // value_type:
<span class="lineNum">     412 </span>                :            :   // Alloc::value_type
<span class="lineNum">     413 </span>                :            :   using value_type = typename Alloc::value_type;
<span class="lineNum">     414 </span>                :            : 
<span class="lineNum">     415 </span>                :            :   // pointer:
<span class="lineNum">     416 </span>                :            :   // Alloc::pointer if present, otherwise value_type*
<span class="lineNum">     417 </span>                :            :   using pointer = memory_internal::ExtractOrT&lt;memory_internal::GetPointer,
<span class="lineNum">     418 </span>                :            :                                               Alloc, value_type*&gt;;
<span class="lineNum">     419 </span>                :            : 
<span class="lineNum">     420 </span>                :            :   // const_pointer:
<span class="lineNum">     421 </span>                :            :   // Alloc::const_pointer if present, otherwise
<span class="lineNum">     422 </span>                :            :   // absl::pointer_traits&lt;pointer&gt;::rebind&lt;const value_type&gt;
<span class="lineNum">     423 </span>                :            :   using const_pointer =
<span class="lineNum">     424 </span>                :            :       memory_internal::ExtractOrT&lt;memory_internal::GetConstPointer, Alloc,
<span class="lineNum">     425 </span>                :            :                                   typename absl::pointer_traits&lt;pointer&gt;::
<span class="lineNum">     426 </span>                :            :                                       template rebind&lt;const value_type&gt;&gt;;
<span class="lineNum">     427 </span>                :            : 
<span class="lineNum">     428 </span>                :            :   // void_pointer:
<span class="lineNum">     429 </span>                :            :   // Alloc::void_pointer if present, otherwise
<span class="lineNum">     430 </span>                :            :   // absl::pointer_traits&lt;pointer&gt;::rebind&lt;void&gt;
<span class="lineNum">     431 </span>                :            :   using void_pointer = memory_internal::ExtractOrT&lt;
<span class="lineNum">     432 </span>                :            :       memory_internal::GetVoidPointer, Alloc,
<span class="lineNum">     433 </span>                :            :       typename absl::pointer_traits&lt;pointer&gt;::template rebind&lt;void&gt;&gt;;
<span class="lineNum">     434 </span>                :            : 
<span class="lineNum">     435 </span>                :            :   // const_void_pointer:
<span class="lineNum">     436 </span>                :            :   // Alloc::const_void_pointer if present, otherwise
<span class="lineNum">     437 </span>                :            :   // absl::pointer_traits&lt;pointer&gt;::rebind&lt;const void&gt;
<span class="lineNum">     438 </span>                :            :   using const_void_pointer = memory_internal::ExtractOrT&lt;
<span class="lineNum">     439 </span>                :            :       memory_internal::GetConstVoidPointer, Alloc,
<span class="lineNum">     440 </span>                :            :       typename absl::pointer_traits&lt;pointer&gt;::template rebind&lt;const void&gt;&gt;;
<span class="lineNum">     441 </span>                :            : 
<span class="lineNum">     442 </span>                :            :   // difference_type:
<span class="lineNum">     443 </span>                :            :   // Alloc::difference_type if present, otherwise
<span class="lineNum">     444 </span>                :            :   // absl::pointer_traits&lt;pointer&gt;::difference_type
<span class="lineNum">     445 </span>                :            :   using difference_type = memory_internal::ExtractOrT&lt;
<span class="lineNum">     446 </span>                :            :       memory_internal::GetDifferenceType, Alloc,
<span class="lineNum">     447 </span>                :            :       typename absl::pointer_traits&lt;pointer&gt;::difference_type&gt;;
<span class="lineNum">     448 </span>                :            : 
<span class="lineNum">     449 </span>                :            :   // size_type:
<span class="lineNum">     450 </span>                :            :   // Alloc::size_type if present, otherwise
<span class="lineNum">     451 </span>                :            :   // std::make_unsigned&lt;difference_type&gt;::type
<span class="lineNum">     452 </span>                :            :   using size_type = memory_internal::ExtractOrT&lt;
<span class="lineNum">     453 </span>                :            :       memory_internal::GetSizeType, Alloc,
<span class="lineNum">     454 </span>                :            :       typename std::make_unsigned&lt;difference_type&gt;::type&gt;;
<span class="lineNum">     455 </span>                :            : 
<span class="lineNum">     456 </span>                :            :   // propagate_on_container_copy_assignment:
<span class="lineNum">     457 </span>                :            :   // Alloc::propagate_on_container_copy_assignment if present, otherwise
<span class="lineNum">     458 </span>                :            :   // std::false_type
<span class="lineNum">     459 </span>                :            :   using propagate_on_container_copy_assignment = memory_internal::ExtractOrT&lt;
<span class="lineNum">     460 </span>                :            :       memory_internal::GetPropagateOnContainerCopyAssignment, Alloc,
<span class="lineNum">     461 </span>                :            :       std::false_type&gt;;
<span class="lineNum">     462 </span>                :            : 
<span class="lineNum">     463 </span>                :            :   // propagate_on_container_move_assignment:
<span class="lineNum">     464 </span>                :            :   // Alloc::propagate_on_container_move_assignment if present, otherwise
<span class="lineNum">     465 </span>                :            :   // std::false_type
<span class="lineNum">     466 </span>                :            :   using propagate_on_container_move_assignment = memory_internal::ExtractOrT&lt;
<span class="lineNum">     467 </span>                :            :       memory_internal::GetPropagateOnContainerMoveAssignment, Alloc,
<span class="lineNum">     468 </span>                :            :       std::false_type&gt;;
<span class="lineNum">     469 </span>                :            : 
<span class="lineNum">     470 </span>                :            :   // propagate_on_container_swap:
<span class="lineNum">     471 </span>                :            :   // Alloc::propagate_on_container_swap if present, otherwise std::false_type
<span class="lineNum">     472 </span>                :            :   using propagate_on_container_swap =
<span class="lineNum">     473 </span>                :            :       memory_internal::ExtractOrT&lt;memory_internal::GetPropagateOnContainerSwap,
<span class="lineNum">     474 </span>                :            :                                   Alloc, std::false_type&gt;;
<span class="lineNum">     475 </span>                :            : 
<span class="lineNum">     476 </span>                :            :   // is_always_equal:
<span class="lineNum">     477 </span>                :            :   // Alloc::is_always_equal if present, otherwise std::is_empty&lt;Alloc&gt;::type
<span class="lineNum">     478 </span>                :            :   using is_always_equal =
<span class="lineNum">     479 </span>                :            :       memory_internal::ExtractOrT&lt;memory_internal::GetIsAlwaysEqual, Alloc,
<span class="lineNum">     480 </span>                :            :                                   typename std::is_empty&lt;Alloc&gt;::type&gt;;
<span class="lineNum">     481 </span>                :            : 
<span class="lineNum">     482 </span>                :            :   // rebind_alloc:
<span class="lineNum">     483 </span>                :            :   // Alloc::rebind&lt;T&gt;::other if present, otherwise Alloc&lt;T, Args&gt; if this Alloc
<span class="lineNum">     484 </span>                :            :   // is Alloc&lt;U, Args&gt;
<span class="lineNum">     485 </span>                :            :   template &lt;typename T&gt;
<span class="lineNum">     486 </span>                :            :   using rebind_alloc = typename memory_internal::RebindAlloc&lt;Alloc, T&gt;::type;
<span class="lineNum">     487 </span>                :            : 
<span class="lineNum">     488 </span>                :            :   // rebind_traits:
<span class="lineNum">     489 </span>                :            :   // absl::allocator_traits&lt;rebind_alloc&lt;T&gt;&gt;
<span class="lineNum">     490 </span>                :            :   template &lt;typename T&gt;
<span class="lineNum">     491 </span>                :            :   using rebind_traits = absl::allocator_traits&lt;rebind_alloc&lt;T&gt;&gt;;
<span class="lineNum">     492 </span>                :            : 
<span class="lineNum">     493 </span>                :            :   // allocate(Alloc&amp; a, size_type n):
<span class="lineNum">     494 </span>                :            :   // Calls a.allocate(n)
<span class="lineNum">     495 </span>                :            :   static pointer allocate(Alloc&amp; a,  // NOLINT(runtime/references)
<span class="lineNum">     496 </span>                :            :                           size_type n) {
<span class="lineNum">     497 </span>                :            :     return a.allocate(n);
<span class="lineNum">     498 </span>                :            :   }
<span class="lineNum">     499 </span>                :            : 
<span class="lineNum">     500 </span>                :            :   // allocate(Alloc&amp; a, size_type n, const_void_pointer hint):
<span class="lineNum">     501 </span>                :            :   // Calls a.allocate(n, hint) if possible.
<span class="lineNum">     502 </span>                :            :   // If not possible, calls a.allocate(n)
<span class="lineNum">     503 </span>                :            :   static pointer allocate(Alloc&amp; a, size_type n,  // NOLINT(runtime/references)
<span class="lineNum">     504 </span>                :            :                           const_void_pointer hint) {
<span class="lineNum">     505 </span>                :            :     return allocate_impl(0, a, n, hint);
<span class="lineNum">     506 </span>                :            :   }
<span class="lineNum">     507 </span>                :            : 
<span class="lineNum">     508 </span>                :            :   // deallocate(Alloc&amp; a, pointer p, size_type n):
<span class="lineNum">     509 </span>                :            :   // Calls a.deallocate(p, n)
<span class="lineNum">     510 </span>                :            :   static void deallocate(Alloc&amp; a, pointer p,  // NOLINT(runtime/references)
<span class="lineNum">     511 </span>                :            :                          size_type n) {
<span class="lineNum">     512 </span>                :            :     a.deallocate(p, n);
<span class="lineNum">     513 </span>                :            :   }
<span class="lineNum">     514 </span>                :            : 
<span class="lineNum">     515 </span>                :            :   // construct(Alloc&amp; a, T* p, Args&amp;&amp;... args):
<span class="lineNum">     516 </span>                :            :   // Calls a.construct(p, std::forward&lt;Args&gt;(args)...) if possible.
<span class="lineNum">     517 </span>                :            :   // If not possible, calls
<span class="lineNum">     518 </span>                :            :   //   ::new (static_cast&lt;void*&gt;(p)) T(std::forward&lt;Args&gt;(args)...)
<span class="lineNum">     519 </span>                :            :   template &lt;typename T, typename... Args&gt;
<span class="lineNum">     520 </span>                :            :   static void construct(Alloc&amp; a, T* p,  // NOLINT(runtime/references)
<span class="lineNum">     521 </span>                :            :                         Args&amp;&amp;... args) {
<span class="lineNum">     522 </span>                :            :     construct_impl(0, a, p, std::forward&lt;Args&gt;(args)...);
<span class="lineNum">     523 </span>                :            :   }
<span class="lineNum">     524 </span>                :            : 
<span class="lineNum">     525 </span>                :            :   // destroy(Alloc&amp; a, T* p):
<span class="lineNum">     526 </span>                :            :   // Calls a.destroy(p) if possible. If not possible, calls p-&gt;~T().
<span class="lineNum">     527 </span>                :            :   template &lt;typename T&gt;
<span class="lineNum">     528 </span>                :            :   static void destroy(Alloc&amp; a, T* p) {  // NOLINT(runtime/references)
<span class="lineNum">     529 </span>                :            :     destroy_impl(0, a, p);
<span class="lineNum">     530 </span>                :            :   }
<span class="lineNum">     531 </span>                :            : 
<span class="lineNum">     532 </span>                :            :   // max_size(const Alloc&amp; a):
<span class="lineNum">     533 </span>                :            :   // Returns a.max_size() if possible. If not possible, returns
<span class="lineNum">     534 </span>                :            :   //   std::numeric_limits&lt;size_type&gt;::max() / sizeof(value_type)
<span class="lineNum">     535 </span>                :            :   static size_type max_size(const Alloc&amp; a) { return max_size_impl(0, a); }
<span class="lineNum">     536 </span>                :            : 
<span class="lineNum">     537 </span>                :            :   // select_on_container_copy_construction(const Alloc&amp; a):
<span class="lineNum">     538 </span>                :            :   // Returns a.select_on_container_copy_construction() if possible.
<span class="lineNum">     539 </span>                :            :   // If not possible, returns a.
<span class="lineNum">     540 </span>                :            :   static Alloc select_on_container_copy_construction(const Alloc&amp; a) {
<span class="lineNum">     541 </span>                :            :     return select_on_container_copy_construction_impl(0, a);
<span class="lineNum">     542 </span>                :            :   }
<span class="lineNum">     543 </span>                :            : 
<span class="lineNum">     544 </span>                :            :  private:
<span class="lineNum">     545 </span>                :            :   template &lt;typename A&gt;
<span class="lineNum">     546 </span>                :            :   static auto allocate_impl(int, A&amp; a,  // NOLINT(runtime/references)
<span class="lineNum">     547 </span>                :            :                             size_type n, const_void_pointer hint)
<span class="lineNum">     548 </span>                :            :       -&gt; decltype(a.allocate(n, hint)) {
<span class="lineNum">     549 </span>                :            :     return a.allocate(n, hint);
<span class="lineNum">     550 </span>                :            :   }
<span class="lineNum">     551 </span>                :            :   static pointer allocate_impl(char, Alloc&amp; a,  // NOLINT(runtime/references)
<span class="lineNum">     552 </span>                :            :                                size_type n, const_void_pointer) {
<span class="lineNum">     553 </span>                :            :     return a.allocate(n);
<span class="lineNum">     554 </span>                :            :   }
<span class="lineNum">     555 </span>                :            : 
<span class="lineNum">     556 </span>                :            :   template &lt;typename A, typename... Args&gt;
<span class="lineNum">     557 </span>                :            :   static auto construct_impl(int, A&amp; a,  // NOLINT(runtime/references)
<span class="lineNum">     558 </span>                :            :                              Args&amp;&amp;... args)
<span class="lineNum">     559 </span>                :            :       -&gt; decltype(a.construct(std::forward&lt;Args&gt;(args)...)) {
<span class="lineNum">     560 </span>                :            :     a.construct(std::forward&lt;Args&gt;(args)...);
<span class="lineNum">     561 </span>                :            :   }
<span class="lineNum">     562 </span>                :            : 
<span class="lineNum">     563 </span>                :            :   template &lt;typename T, typename... Args&gt;
<span class="lineNum">     564 </span>                :            :   static void construct_impl(char, Alloc&amp;, T* p, Args&amp;&amp;... args) {
<span class="lineNum">     565 </span>                :            :     ::new (static_cast&lt;void*&gt;(p)) T(std::forward&lt;Args&gt;(args)...);
<span class="lineNum">     566 </span>                :            :   }
<span class="lineNum">     567 </span>                :            : 
<span class="lineNum">     568 </span>                :            :   template &lt;typename A, typename T&gt;
<span class="lineNum">     569 </span>                :            :   static auto destroy_impl(int, A&amp; a,  // NOLINT(runtime/references)
<span class="lineNum">     570 </span>                :            :                            T* p) -&gt; decltype(a.destroy(p)) {
<span class="lineNum">     571 </span>                :            :     a.destroy(p);
<span class="lineNum">     572 </span>                :            :   }
<span class="lineNum">     573 </span>                :            :   template &lt;typename T&gt;
<span class="lineNum">     574 </span>                :            :   static void destroy_impl(char, Alloc&amp;, T* p) {
<span class="lineNum">     575 </span>                :            :     p-&gt;~T();
<span class="lineNum">     576 </span>                :            :   }
<span class="lineNum">     577 </span>                :            : 
<span class="lineNum">     578 </span>                :            :   template &lt;typename A&gt;
<span class="lineNum">     579 </span>                :            :   static auto max_size_impl(int, const A&amp; a) -&gt; decltype(a.max_size()) {
<span class="lineNum">     580 </span>                :            :     return a.max_size();
<span class="lineNum">     581 </span>                :            :   }
<span class="lineNum">     582 </span>                :            :   static size_type max_size_impl(char, const Alloc&amp;) {
<span class="lineNum">     583 </span>                :            :     return std::numeric_limits&lt;size_type&gt;::max() / sizeof(value_type);
<span class="lineNum">     584 </span>                :            :   }
<span class="lineNum">     585 </span>                :            : 
<span class="lineNum">     586 </span>                :            :   template &lt;typename A&gt;
<span class="lineNum">     587 </span>                :            :   static auto select_on_container_copy_construction_impl(int, const A&amp; a)
<span class="lineNum">     588 </span>                :            :       -&gt; decltype(a.select_on_container_copy_construction()) {
<span class="lineNum">     589 </span>                :            :     return a.select_on_container_copy_construction();
<span class="lineNum">     590 </span>                :            :   }
<span class="lineNum">     591 </span>                :            :   static Alloc select_on_container_copy_construction_impl(char,
<span class="lineNum">     592 </span>                :            :                                                           const Alloc&amp; a) {
<span class="lineNum">     593 </span>                :            :     return a;
<span class="lineNum">     594 </span>                :            :   }
<span class="lineNum">     595 </span>                :            : };
<span class="lineNum">     596 </span>                :            : 
<span class="lineNum">     597 </span>                :            : namespace memory_internal {
<span class="lineNum">     598 </span>                :            : 
<span class="lineNum">     599 </span>                :            : // This template alias transforms Alloc::is_nothrow into a metafunction with
<span class="lineNum">     600 </span>                :            : // Alloc as a parameter so it can be used with ExtractOrT&lt;&gt;.
<span class="lineNum">     601 </span>                :            : template &lt;typename Alloc&gt;
<span class="lineNum">     602 </span>                :            : using GetIsNothrow = typename Alloc::is_nothrow;
<span class="lineNum">     603 </span>                :            : 
<span class="lineNum">     604 </span>                :            : }  // namespace memory_internal
<span class="lineNum">     605 </span>                :            : 
<span class="lineNum">     606 </span>                :            : // ABSL_ALLOCATOR_NOTHROW is a build time configuration macro for user to
<span class="lineNum">     607 </span>                :            : // specify whether the default allocation function can throw or never throws.
<span class="lineNum">     608 </span>                :            : // If the allocation function never throws, user should define it to a non-zero
<span class="lineNum">     609 </span>                :            : // value (e.g. via `-DABSL_ALLOCATOR_NOTHROW`).
<span class="lineNum">     610 </span>                :            : // If the allocation function can throw, user should leave it undefined or
<span class="lineNum">     611 </span>                :            : // define it to zero.
<span class="lineNum">     612 </span>                :            : //
<span class="lineNum">     613 </span>                :            : // allocator_is_nothrow&lt;Alloc&gt; is a traits class that derives from
<span class="lineNum">     614 </span>                :            : // Alloc::is_nothrow if present, otherwise std::false_type. It's specialized
<span class="lineNum">     615 </span>                :            : // for Alloc = std::allocator&lt;T&gt; for any type T according to the state of
<span class="lineNum">     616 </span>                :            : // ABSL_ALLOCATOR_NOTHROW.
<span class="lineNum">     617 </span>                :            : //
<span class="lineNum">     618 </span>                :            : // default_allocator_is_nothrow is a class that derives from std::true_type
<span class="lineNum">     619 </span>                :            : // when the default allocator (global operator new) never throws, and
<span class="lineNum">     620 </span>                :            : // std::false_type when it can throw. It is a convenience shorthand for writing
<span class="lineNum">     621 </span>                :            : // allocator_is_nothrow&lt;std::allocator&lt;T&gt;&gt; (T can be any type).
<span class="lineNum">     622 </span>                :            : // NOTE: allocator_is_nothrow&lt;std::allocator&lt;T&gt;&gt; is guaranteed to derive from
<span class="lineNum">     623 </span>                :            : // the same type for all T, because users should specialize neither
<span class="lineNum">     624 </span>                :            : // allocator_is_nothrow nor std::allocator.
<span class="lineNum">     625 </span>                :            : template &lt;typename Alloc&gt;
<span class="lineNum">     626 </span>                :            : struct allocator_is_nothrow
<span class="lineNum">     627 </span>                :            :     : memory_internal::ExtractOrT&lt;memory_internal::GetIsNothrow, Alloc,
<span class="lineNum">     628 </span>                :            :                                   std::false_type&gt; {};
<span class="lineNum">     629 </span>                :            : 
<span class="lineNum">     630 </span>                :            : #if ABSL_ALLOCATOR_NOTHROW
<span class="lineNum">     631 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     632 </span>                :            : struct allocator_is_nothrow&lt;std::allocator&lt;T&gt;&gt; : std::true_type {};
<span class="lineNum">     633 </span>                :            : struct default_allocator_is_nothrow : std::true_type {};
<span class="lineNum">     634 </span>                :            : #else
<span class="lineNum">     635 </span>                :            : struct default_allocator_is_nothrow : std::false_type {};
<span class="lineNum">     636 </span>                :            : #endif
<span class="lineNum">     637 </span>                :            : 
<span class="lineNum">     638 </span>                :            : }  // namespace absl
<span class="lineNum">     639 </span>                :            : 
<span class="lineNum">     640 </span>                :            : #endif  // ABSL_MEMORY_MEMORY_H_
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

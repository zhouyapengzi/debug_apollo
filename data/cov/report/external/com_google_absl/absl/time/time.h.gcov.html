<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - stripped_conv.info - external/com_google_absl/absl/time/time.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../index.html">top level</a> - <a href="index.html">external/com_google_absl/absl/time</a> - time.h<span style="font-size: 80%;"> (source / <a href="time.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">stripped_conv.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">15</td>
            <td class="headerCovTableEntry">31</td>
            <td class="headerCovTableEntryLo">48.4 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2020-05-21 16:34:32</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntry">17</td>
            <td class="headerCovTableEntryLo">58.8 %</td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td></td>
            <td class="headerItem">Branches:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">10</td>
            <td class="headerCovTableEntryLo">10.0 %</td>
          </tr>
          <tr><td><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">           Branch data     Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>                :            : // Copyright 2017 The Abseil Authors.</a>
<span class="lineNum">       2 </span>                :            : //
<span class="lineNum">       3 </span>                :            : // Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
<span class="lineNum">       4 </span>                :            : // you may not use this file except in compliance with the License.
<span class="lineNum">       5 </span>                :            : // You may obtain a copy of the License at
<span class="lineNum">       6 </span>                :            : //
<span class="lineNum">       7 </span>                :            : //      http://www.apache.org/licenses/LICENSE-2.0
<span class="lineNum">       8 </span>                :            : //
<span class="lineNum">       9 </span>                :            : // Unless required by applicable law or agreed to in writing, software
<span class="lineNum">      10 </span>                :            : // distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
<span class="lineNum">      11 </span>                :            : // WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
<span class="lineNum">      12 </span>                :            : // See the License for the specific language governing permissions and
<span class="lineNum">      13 </span>                :            : // limitations under the License.
<span class="lineNum">      14 </span>                :            : //
<span class="lineNum">      15 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">      16 </span>                :            : // File: time.h
<span class="lineNum">      17 </span>                :            : // -----------------------------------------------------------------------------
<span class="lineNum">      18 </span>                :            : //
<span class="lineNum">      19 </span>                :            : // This header file defines abstractions for computing with absolute points
<span class="lineNum">      20 </span>                :            : // in time, durations of time, and formatting and parsing time within a given
<span class="lineNum">      21 </span>                :            : // time zone. The following abstractions are defined:
<span class="lineNum">      22 </span>                :            : //
<span class="lineNum">      23 </span>                :            : //  * `absl::Time` defines an absolute, specific instance in time
<span class="lineNum">      24 </span>                :            : //  * `absl::Duration` defines a signed, fixed-length span of time
<span class="lineNum">      25 </span>                :            : //  * `absl::TimeZone` defines geopolitical time zone regions (as collected
<span class="lineNum">      26 </span>                :            : //     within the IANA Time Zone database (https://www.iana.org/time-zones)).
<span class="lineNum">      27 </span>                :            : //
<span class="lineNum">      28 </span>                :            : // Example:
<span class="lineNum">      29 </span>                :            : //
<span class="lineNum">      30 </span>                :            : //   absl::TimeZone nyc;
<span class="lineNum">      31 </span>                :            : //
<span class="lineNum">      32 </span>                :            : //   // LoadTimeZone may fail so it's always better to check for success.
<span class="lineNum">      33 </span>                :            : //   if (!absl::LoadTimeZone(&quot;America/New_York&quot;, &amp;nyc)) {
<span class="lineNum">      34 </span>                :            : //      // handle error case
<span class="lineNum">      35 </span>                :            : //   }
<span class="lineNum">      36 </span>                :            : //
<span class="lineNum">      37 </span>                :            : //   // My flight leaves NYC on Jan 2, 2017 at 03:04:05
<span class="lineNum">      38 </span>                :            : //   absl::Time takeoff = absl::FromDateTime(2017, 1, 2, 3, 4, 5, nyc);
<span class="lineNum">      39 </span>                :            : //   absl::Duration flight_duration = absl::Hours(21) + absl::Minutes(35);
<span class="lineNum">      40 </span>                :            : //   absl::Time landing = takeoff + flight_duration;
<span class="lineNum">      41 </span>                :            : //
<span class="lineNum">      42 </span>                :            : //   absl::TimeZone syd;
<span class="lineNum">      43 </span>                :            : //   if (!absl::LoadTimeZone(&quot;Australia/Sydney&quot;, &amp;syd)) {
<span class="lineNum">      44 </span>                :            : //      // handle error case
<span class="lineNum">      45 </span>                :            : //   }
<span class="lineNum">      46 </span>                :            : //   std::string s = absl::FormatTime(
<span class="lineNum">      47 </span>                :            : //       &quot;My flight will land in Sydney on %Y-%m-%d at %H:%M:%S&quot;,
<span class="lineNum">      48 </span>                :            : //       landing, syd);
<span class="lineNum">      49 </span>                :            : //
<span class="lineNum">      50 </span>                :            : #ifndef ABSL_TIME_TIME_H_
<span class="lineNum">      51 </span>                :            : #define ABSL_TIME_TIME_H_
<span class="lineNum">      52 </span>                :            : 
<span class="lineNum">      53 </span>                :            : #if !defined(_WIN32)
<span class="lineNum">      54 </span>                :            : #include &lt;sys/time.h&gt;
<span class="lineNum">      55 </span>                :            : #else
<span class="lineNum">      56 </span>                :            : #include &lt;winsock2.h&gt;
<span class="lineNum">      57 </span>                :            : #endif
<span class="lineNum">      58 </span>                :            : #include &lt;chrono&gt;  // NOLINT(build/c++11)
<span class="lineNum">      59 </span>                :            : #include &lt;cstdint&gt;
<span class="lineNum">      60 </span>                :            : #include &lt;ctime&gt;
<span class="lineNum">      61 </span>                :            : #include &lt;ostream&gt;
<span class="lineNum">      62 </span>                :            : #include &lt;string&gt;
<span class="lineNum">      63 </span>                :            : #include &lt;type_traits&gt;
<span class="lineNum">      64 </span>                :            : #include &lt;utility&gt;
<span class="lineNum">      65 </span>                :            : 
<span class="lineNum">      66 </span>                :            : #include &quot;absl/base/port.h&quot;  // Needed for string vs std::string
<span class="lineNum">      67 </span>                :            : #include &quot;absl/time/internal/cctz/include/cctz/time_zone.h&quot;
<span class="lineNum">      68 </span>                :            : 
<span class="lineNum">      69 </span>                :            : namespace absl {
<span class="lineNum">      70 </span>                :            : 
<span class="lineNum">      71 </span>                :            : class Duration;  // Defined below
<span class="lineNum">      72 </span>                :            : class Time;      // Defined below
<span class="lineNum">      73 </span>                :            : class TimeZone;  // Defined below
<span class="lineNum">      74 </span>                :            : 
<span class="lineNum">      75 </span>                :            : namespace time_internal {
<span class="lineNum">      76 </span>                :            : int64_t IDivDuration(bool satq, Duration num, Duration den, Duration* rem);
<span class="lineNum">      77 </span>                :            : constexpr Time FromUnixDuration(Duration d);
<span class="lineNum">      78 </span>                :            : constexpr Duration ToUnixDuration(Time t);
<span class="lineNum">      79 </span>                :            : constexpr int64_t GetRepHi(Duration d);
<span class="lineNum">      80 </span>                :            : constexpr uint32_t GetRepLo(Duration d);
<span class="lineNum">      81 </span>                :            : constexpr Duration MakeDuration(int64_t hi, uint32_t lo);
<span class="lineNum">      82 </span>                :            : constexpr Duration MakeDuration(int64_t hi, int64_t lo);
<span class="lineNum">      83 </span>                :            : constexpr int64_t kTicksPerNanosecond = 4;
<span class="lineNum">      84 </span>                :            : constexpr int64_t kTicksPerSecond = 1000 * 1000 * 1000 * kTicksPerNanosecond;
<span class="lineNum">      85 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">      86 </span>                :            : using IsFloatingPoint =
<span class="lineNum">      87 </span>                :            :     typename std::enable_if&lt;std::is_floating_point&lt;T&gt;::value, int&gt;::type;
<span class="lineNum">      88 </span>                :            : }  // namespace time_internal
<span class="lineNum">      89 </span>                :            : 
<span class="lineNum">      90 </span>                :            : // Duration
<span class="lineNum">      91 </span>                :            : //
<span class="lineNum">      92 </span>                :            : // The `absl::Duration` class represents a signed, fixed-length span of time.
<span class="lineNum">      93 </span>                :            : // A `Duration` is generated using a unit-specific factory function, or is
<span class="lineNum">      94 </span>                :            : // the result of subtracting one `absl::Time` from another. Durations behave
<span class="lineNum">      95 </span>                :            : // like unit-safe integers and they support all the natural integer-like
<span class="lineNum">      96 </span>                :            : // arithmetic operations. Arithmetic overflows and saturates at +/- infinity.
<span class="lineNum">      97 </span>                :            : // `Duration` should be passed by value rather than const reference.
<span class="lineNum">      98 </span>                :            : //
<span class="lineNum">      99 </span>                :            : // Factory functions `Nanoseconds()`, `Microseconds()`, `Milliseconds()`,
<span class="lineNum">     100 </span>                :            : // `Seconds()`, `Minutes()`, `Hours()` and `InfiniteDuration()` allow for
<span class="lineNum">     101 </span>                :            : // creation of constexpr `Duration` values
<span class="lineNum">     102 </span>                :            : //
<span class="lineNum">     103 </span>                :            : // Examples:
<span class="lineNum">     104 </span>                :            : //
<span class="lineNum">     105 </span>                :            : //   constexpr absl::Duration ten_ns = absl::Nanoseconds(10);
<span class="lineNum">     106 </span>                :            : //   constexpr absl::Duration min = absl::Minutes(1);
<span class="lineNum">     107 </span>                :            : //   constexpr absl::Duration hour = absl::Hours(1);
<span class="lineNum">     108 </span>                :            : //   absl::Duration dur = 60 * min;  // dur == hour
<span class="lineNum">     109 </span>                :            : //   absl::Duration half_sec = absl::Milliseconds(500);
<span class="lineNum">     110 </span>                :            : //   absl::Duration quarter_sec = 0.25 * absl::Seconds(1);
<span class="lineNum">     111 </span>                :            : //
<span class="lineNum">     112 </span>                :            : // `Duration` values can be easily converted to an integral number of units
<span class="lineNum">     113 </span>                :            : // using the division operator.
<span class="lineNum">     114 </span>                :            : //
<span class="lineNum">     115 </span>                :            : // Example:
<span class="lineNum">     116 </span>                :            : //
<span class="lineNum">     117 </span>                :            : //   constexpr absl::Duration dur = absl::Milliseconds(1500);
<span class="lineNum">     118 </span>                :            : //   int64_t ns = dur / absl::Nanoseconds(1);   // ns == 1500000000
<span class="lineNum">     119 </span>                :            : //   int64_t ms = dur / absl::Milliseconds(1);  // ms == 1500
<span class="lineNum">     120 </span>                :            : //   int64_t sec = dur / absl::Seconds(1);    // sec == 1 (subseconds truncated)
<span class="lineNum">     121 </span>                :            : //   int64_t min = dur / absl::Minutes(1);    // min == 0
<span class="lineNum">     122 </span>                :            : //
<span class="lineNum">     123 </span>                :            : // See the `IDivDuration()` and `FDivDuration()` functions below for details on
<span class="lineNum">     124 </span>                :            : // how to access the fractional parts of the quotient.
<span class="lineNum">     125 </span>                :            : //
<span class="lineNum">     126 </span>                :            : // Alternatively, conversions can be performed using helpers such as
<span class="lineNum">     127 </span>                :            : // `ToInt64Microseconds()` and `ToDoubleSeconds()`.
<span class="lineNum">     128 </span>                :            : class Duration {
<span class="lineNum">     129 </span>                :            :  public:
<span class="lineNum">     130 </span>                :            :   // Value semantics.
<span class="lineNum">     131 </span>                :            :   constexpr Duration() : rep_hi_(0), rep_lo_(0) {}  // zero-length duration
<span class="lineNum">     132 </span>                :            : 
<span class="lineNum">     133 </span>                :            :   // Compound assignment operators.
<span class="lineNum">     134 </span>                :            :   Duration&amp; operator+=(Duration d);
<span class="lineNum">     135 </span>                :            :   Duration&amp; operator-=(Duration d);
<span class="lineNum">     136 </span>                :            :   Duration&amp; operator*=(int64_t r);
<span class="lineNum">     137 </span>                :            :   Duration&amp; operator*=(double r);
<span class="lineNum">     138 </span>                :            :   Duration&amp; operator/=(int64_t r);
<span class="lineNum">     139 </span>                :            :   Duration&amp; operator/=(double r);
<span class="lineNum">     140 </span>                :            :   Duration&amp; operator%=(Duration rhs);
<span class="lineNum">     141 </span>                :            : 
<span class="lineNum">     142 </span>                :            :   // Overloads that forward to either the int64_t or double overloads above.
<span class="lineNum">     143 </span>                :            :   template &lt;typename T&gt;
<span class="lineNum">     144 </span>                :            :   Duration&amp; operator*=(T r) {
<span class="lineNum">     145 </span>                :            :     int64_t x = r;
<span class="lineNum">     146 </span>                :            :     return *this *= x;
<span class="lineNum">     147 </span>                :            :   }
<span class="lineNum">     148 </span>                :            :   template &lt;typename T&gt;
<span class="lineNum">     149 </span>                :            :   Duration&amp; operator/=(T r) {
<span class="lineNum">     150 </span>                :            :     int64_t x = r;
<span class="lineNum">     151 </span>                :            :     return *this /= x;
<span class="lineNum">     152 </span>                :            :   }
<span class="lineNum">     153 </span>                :            :   Duration&amp; operator*=(float r) { return *this *= static_cast&lt;double&gt;(r); }
<span class="lineNum">     154 </span>                :            :   Duration&amp; operator/=(float r) { return *this /= static_cast&lt;double&gt;(r); }
<span class="lineNum">     155 </span>                :            : 
<span class="lineNum">     156 </span>                :            :  private:
<span class="lineNum">     157 </span>                :            :   friend constexpr int64_t time_internal::GetRepHi(Duration d);
<span class="lineNum">     158 </span>                :            :   friend constexpr uint32_t time_internal::GetRepLo(Duration d);
<a name="159"><span class="lineNum">     159 </span>                :            :   friend constexpr Duration time_internal::MakeDuration(int64_t hi,</a>
<span class="lineNum">     160 </span>                :            :                                                         uint32_t lo);
<span class="lineNum">     161 </span>                :<span class="lineCov">         35 :   constexpr Duration(int64_t hi, uint32_t lo) : rep_hi_(hi), rep_lo_(lo) {}</span>
<span class="lineNum">     162 </span>                :            :   int64_t rep_hi_;
<span class="lineNum">     163 </span>                :            :   uint32_t rep_lo_;
<span class="lineNum">     164 </span>                :            : };
<span class="lineNum">     165 </span>                :            : 
<a name="166"><span class="lineNum">     166 </span>                :            : // Relational Operators</a>
<span class="lineNum">     167 </span>                :            : constexpr bool operator&lt;(Duration lhs, Duration rhs);
<span class="lineNum">     168 </span>                :<span class="lineNoCov">          0 : constexpr bool operator&gt;(Duration lhs, Duration rhs) { return rhs &lt; lhs; }</span>
<span class="lineNum">     169 </span>                :            : constexpr bool operator&gt;=(Duration lhs, Duration rhs) { return !(lhs &lt; rhs); }
<span class="lineNum">     170 </span>                :            : constexpr bool operator&lt;=(Duration lhs, Duration rhs) { return !(rhs &lt; lhs); }
<span class="lineNum">     171 </span>                :            : constexpr bool operator==(Duration lhs, Duration rhs);
<span class="lineNum">     172 </span>                :            : constexpr bool operator!=(Duration lhs, Duration rhs) { return !(lhs == rhs); }
<span class="lineNum">     173 </span>                :            : 
<span class="lineNum">     174 </span>                :            : // Additive Operators
<a name="175"><span class="lineNum">     175 </span>                :            : constexpr Duration operator-(Duration d);</a>
<span class="lineNum">     176 </span>                :            : inline Duration operator+(Duration lhs, Duration rhs) { return lhs += rhs; }
<span class="lineNum">     177 </span>                :<span class="lineNoCov">          0 : inline Duration operator-(Duration lhs, Duration rhs) { return lhs -= rhs; }</span>
<span class="lineNum">     178 </span>                :            : 
<span class="lineNum">     179 </span>                :            : // Multiplicative Operators
<span class="lineNum">     180 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     181 </span>                :            : inline Duration operator*(Duration lhs, T rhs) {
<span class="lineNum">     182 </span>                :            :   return lhs *= rhs;
<span class="lineNum">     183 </span>                :            : }
<span class="lineNum">     184 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     185 </span>                :            : inline Duration operator*(T lhs, Duration rhs) {
<span class="lineNum">     186 </span>                :            :   return rhs *= lhs;
<span class="lineNum">     187 </span>                :            : }
<span class="lineNum">     188 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">     189 </span>                :            : inline Duration operator/(Duration lhs, T rhs) {
<span class="lineNum">     190 </span>                :            :   return lhs /= rhs;
<span class="lineNum">     191 </span>                :            : }
<span class="lineNum">     192 </span>                :            : inline int64_t operator/(Duration lhs, Duration rhs) {
<span class="lineNum">     193 </span>                :            :   return time_internal::IDivDuration(true, lhs, rhs,
<span class="lineNum">     194 </span>                :            :                                      &amp;lhs);  // trunc towards zero
<span class="lineNum">     195 </span>                :            : }
<span class="lineNum">     196 </span>                :            : inline Duration operator%(Duration lhs, Duration rhs) { return lhs %= rhs; }
<span class="lineNum">     197 </span>                :            : 
<span class="lineNum">     198 </span>                :            : // IDivDuration()
<span class="lineNum">     199 </span>                :            : //
<span class="lineNum">     200 </span>                :            : // Divides a numerator `Duration` by a denominator `Duration`, returning the
<span class="lineNum">     201 </span>                :            : // quotient and remainder. The remainder always has the same sign as the
<span class="lineNum">     202 </span>                :            : // numerator. The returned quotient and remainder respect the identity:
<span class="lineNum">     203 </span>                :            : //
<span class="lineNum">     204 </span>                :            : //   numerator = denominator * quotient + remainder
<span class="lineNum">     205 </span>                :            : //
<span class="lineNum">     206 </span>                :            : // Returned quotients are capped to the range of `int64_t`, with the difference
<span class="lineNum">     207 </span>                :            : // spilling into the remainder to uphold the above identity. This means that the
<span class="lineNum">     208 </span>                :            : // remainder returned could differ from the remainder returned by
<span class="lineNum">     209 </span>                :            : // `Duration::operator%` for huge quotients.
<span class="lineNum">     210 </span>                :            : //
<span class="lineNum">     211 </span>                :            : // See also the notes on `InfiniteDuration()` below regarding the behavior of
<span class="lineNum">     212 </span>                :            : // division involving zero and infinite durations.
<span class="lineNum">     213 </span>                :            : //
<span class="lineNum">     214 </span>                :            : // Example:
<span class="lineNum">     215 </span>                :            : //
<span class="lineNum">     216 </span>                :            : //   constexpr absl::Duration a =
<span class="lineNum">     217 </span>                :            : //       absl::Seconds(std::numeric_limits&lt;int64_t&gt;::max());  // big
<span class="lineNum">     218 </span>                :            : //   constexpr absl::Duration b = absl::Nanoseconds(1);       // small
<span class="lineNum">     219 </span>                :            : //
<span class="lineNum">     220 </span>                :            : //   absl::Duration rem = a % b;
<span class="lineNum">     221 </span>                :            : //   // rem == absl::ZeroDuration()
<span class="lineNum">     222 </span>                :            : //
<span class="lineNum">     223 </span>                :            : //   // Here, q would overflow int64_t, so rem accounts for the difference.
<span class="lineNum">     224 </span>                :            : //   int64_t q = absl::IDivDuration(a, b, &amp;rem);
<span class="lineNum">     225 </span>                :            : //   // q == std::numeric_limits&lt;int64_t&gt;::max(), rem == a - b * q
<span class="lineNum">     226 </span>                :            : inline int64_t IDivDuration(Duration num, Duration den, Duration* rem) {
<span class="lineNum">     227 </span>                :            :   return time_internal::IDivDuration(true, num, den,
<span class="lineNum">     228 </span>                :            :                                      rem);  // trunc towards zero
<span class="lineNum">     229 </span>                :            : }
<span class="lineNum">     230 </span>                :            : 
<span class="lineNum">     231 </span>                :            : // FDivDuration()
<span class="lineNum">     232 </span>                :            : //
<span class="lineNum">     233 </span>                :            : // Divides a `Duration` numerator into a fractional number of units of a
<span class="lineNum">     234 </span>                :            : // `Duration` denominator.
<span class="lineNum">     235 </span>                :            : //
<span class="lineNum">     236 </span>                :            : // See also the notes on `InfiniteDuration()` below regarding the behavior of
<span class="lineNum">     237 </span>                :            : // division involving zero and infinite durations.
<span class="lineNum">     238 </span>                :            : //
<span class="lineNum">     239 </span>                :            : // Example:
<span class="lineNum">     240 </span>                :            : //
<span class="lineNum">     241 </span>                :            : //   double d = absl::FDivDuration(absl::Milliseconds(1500), absl::Seconds(1));
<span class="lineNum">     242 </span>                :            : //   // d == 1.5
<span class="lineNum">     243 </span>                :            : double FDivDuration(Duration num, Duration den);
<span class="lineNum">     244 </span>                :            : 
<span class="lineNum">     245 </span>                :            : // ZeroDuration()
<span class="lineNum">     246 </span>                :            : //
<span class="lineNum">     247 </span>                :            : // Returns a zero-length duration. This function behaves just like the default
<span class="lineNum">     248 </span>                :            : // constructor, but the name helps make the semantics clear at call sites.
<span class="lineNum">     249 </span>                :            : constexpr Duration ZeroDuration() { return Duration(); }
<span class="lineNum">     250 </span>                :            : 
<span class="lineNum">     251 </span>                :            : // AbsDuration()
<span class="lineNum">     252 </span>                :            : //
<span class="lineNum">     253 </span>                :            : // Returns the absolute value of a duration.
<span class="lineNum">     254 </span>                :            : inline Duration AbsDuration(Duration d) {
<span class="lineNum">     255 </span>                :            :   return (d &lt; ZeroDuration()) ? -d : d;
<span class="lineNum">     256 </span>                :            : }
<span class="lineNum">     257 </span>                :            : 
<span class="lineNum">     258 </span>                :            : // Trunc()
<span class="lineNum">     259 </span>                :            : //
<span class="lineNum">     260 </span>                :            : // Truncates a duration (toward zero) to a multiple of a non-zero unit.
<span class="lineNum">     261 </span>                :            : //
<span class="lineNum">     262 </span>                :            : // Example:
<span class="lineNum">     263 </span>                :            : //
<span class="lineNum">     264 </span>                :            : //   absl::Duration d = absl::Nanoseconds(123456789);
<span class="lineNum">     265 </span>                :            : //   absl::Duration a = absl::Trunc(d, absl::Microseconds(1));  // 123456us
<span class="lineNum">     266 </span>                :            : Duration Trunc(Duration d, Duration unit);
<span class="lineNum">     267 </span>                :            : 
<span class="lineNum">     268 </span>                :            : // Floor()
<span class="lineNum">     269 </span>                :            : //
<span class="lineNum">     270 </span>                :            : // Floors a duration using the passed duration unit to its largest value not
<span class="lineNum">     271 </span>                :            : // greater than the duration.
<span class="lineNum">     272 </span>                :            : //
<span class="lineNum">     273 </span>                :            : // Example:
<span class="lineNum">     274 </span>                :            : //
<span class="lineNum">     275 </span>                :            : //   absl::Duration d = absl::Nanoseconds(123456789);
<span class="lineNum">     276 </span>                :            : //   absl::Duration b = absl::Floor(d, absl::Microseconds(1));  // 123456us
<span class="lineNum">     277 </span>                :            : Duration Floor(Duration d, Duration unit);
<span class="lineNum">     278 </span>                :            : 
<span class="lineNum">     279 </span>                :            : // Ceil()
<span class="lineNum">     280 </span>                :            : //
<span class="lineNum">     281 </span>                :            : // Returns the ceiling of a duration using the passed duration unit to its
<span class="lineNum">     282 </span>                :            : // smallest value not less than the duration.
<span class="lineNum">     283 </span>                :            : //
<span class="lineNum">     284 </span>                :            : // Example:
<span class="lineNum">     285 </span>                :            : //
<span class="lineNum">     286 </span>                :            : //   absl::Duration d = absl::Nanoseconds(123456789);
<span class="lineNum">     287 </span>                :            : //   absl::Duration c = absl::Ceil(d, absl::Microseconds(1));   // 123457us
<span class="lineNum">     288 </span>                :            : Duration Ceil(Duration d, Duration unit);
<span class="lineNum">     289 </span>                :            : 
<span class="lineNum">     290 </span>                :            : // Nanoseconds()
<span class="lineNum">     291 </span>                :            : // Microseconds()
<span class="lineNum">     292 </span>                :            : // Milliseconds()
<span class="lineNum">     293 </span>                :            : // Seconds()
<span class="lineNum">     294 </span>                :            : // Minutes()
<span class="lineNum">     295 </span>                :            : // Hours()
<span class="lineNum">     296 </span>                :            : //
<span class="lineNum">     297 </span>                :            : // Factory functions for constructing `Duration` values from an integral number
<span class="lineNum">     298 </span>                :            : // of the unit indicated by the factory function's name.
<span class="lineNum">     299 </span>                :            : //
<span class="lineNum">     300 </span>                :            : // Note: no &quot;Days()&quot; factory function exists because &quot;a day&quot; is ambiguous. Civil
<span class="lineNum">     301 </span>                :            : // days are not always 24 hours long, and a 24-hour duration often does not
<span class="lineNum">     302 </span>                :            : // correspond with a civil day. If a 24-hour duration is needed, use
<span class="lineNum">     303 </span>                :            : // `absl::Hours(24)`.
<span class="lineNum">     304 </span>                :            : //
<span class="lineNum">     305 </span>                :            : //
<span class="lineNum">     306 </span>                :            : // Example:
<span class="lineNum">     307 </span>                :            : //
<span class="lineNum">     308 </span>                :            : //   absl::Duration a = absl::Seconds(60);
<span class="lineNum">     309 </span>                :            : //   absl::Duration b = absl::Minutes(1);  // b == a
<span class="lineNum">     310 </span>                :            : constexpr Duration Nanoseconds(int64_t n);
<span class="lineNum">     311 </span>                :            : constexpr Duration Microseconds(int64_t n);
<span class="lineNum">     312 </span>                :            : constexpr Duration Milliseconds(int64_t n);
<span class="lineNum">     313 </span>                :            : constexpr Duration Seconds(int64_t n);
<span class="lineNum">     314 </span>                :            : constexpr Duration Minutes(int64_t n);
<span class="lineNum">     315 </span>                :            : constexpr Duration Hours(int64_t n);
<span class="lineNum">     316 </span>                :            : 
<span class="lineNum">     317 </span>                :            : // Factory overloads for constructing `Duration` values from a floating-point
<span class="lineNum">     318 </span>                :            : // number of the unit indicated by the factory function's name. These functions
<span class="lineNum">     319 </span>                :            : // exist for convenience, but they are not as efficient as the integral
<span class="lineNum">     320 </span>                :            : // factories, which should be preferred.
<span class="lineNum">     321 </span>                :            : //
<span class="lineNum">     322 </span>                :            : // Example:
<span class="lineNum">     323 </span>                :            : //   auto a = absl::Seconds(1.5);        // OK
<span class="lineNum">     324 </span>                :            : //   auto b = absl::Milliseconds(1500);  // BETTER
<span class="lineNum">     325 </span>                :            : template &lt;typename T, time_internal::IsFloatingPoint&lt;T&gt; = 0&gt;
<span class="lineNum">     326 </span>                :            : Duration Nanoseconds(T n) {
<span class="lineNum">     327 </span>                :            :   return n * Nanoseconds(1);
<span class="lineNum">     328 </span>                :            : }
<span class="lineNum">     329 </span>                :            : template &lt;typename T, time_internal::IsFloatingPoint&lt;T&gt; = 0&gt;
<span class="lineNum">     330 </span>                :            : Duration Microseconds(T n) {
<span class="lineNum">     331 </span>                :            :   return n * Microseconds(1);
<span class="lineNum">     332 </span>                :            : }
<span class="lineNum">     333 </span>                :            : template &lt;typename T, time_internal::IsFloatingPoint&lt;T&gt; = 0&gt;
<span class="lineNum">     334 </span>                :            : Duration Milliseconds(T n) {
<span class="lineNum">     335 </span>                :            :   return n * Milliseconds(1);
<span class="lineNum">     336 </span>                :            : }
<span class="lineNum">     337 </span>                :            : template &lt;typename T, time_internal::IsFloatingPoint&lt;T&gt; = 0&gt;
<span class="lineNum">     338 </span>                :            : Duration Seconds(T n) {
<span class="lineNum">     339 </span>                :            :   return n * Seconds(1);
<span class="lineNum">     340 </span>                :            : }
<span class="lineNum">     341 </span>                :            : template &lt;typename T, time_internal::IsFloatingPoint&lt;T&gt; = 0&gt;
<span class="lineNum">     342 </span>                :            : Duration Minutes(T n) {
<span class="lineNum">     343 </span>                :            :   return n * Minutes(1);
<span class="lineNum">     344 </span>                :            : }
<span class="lineNum">     345 </span>                :            : template &lt;typename T, time_internal::IsFloatingPoint&lt;T&gt; = 0&gt;
<span class="lineNum">     346 </span>                :            : Duration Hours(T n) {
<span class="lineNum">     347 </span>                :            :   return n * Hours(1);
<span class="lineNum">     348 </span>                :            : }
<span class="lineNum">     349 </span>                :            : 
<span class="lineNum">     350 </span>                :            : // ToInt64Nanoseconds()
<span class="lineNum">     351 </span>                :            : // ToInt64Microseconds()
<span class="lineNum">     352 </span>                :            : // ToInt64Milliseconds()
<span class="lineNum">     353 </span>                :            : // ToInt64Seconds()
<span class="lineNum">     354 </span>                :            : // ToInt64Minutes()
<span class="lineNum">     355 </span>                :            : // ToInt64Hours()
<span class="lineNum">     356 </span>                :            : //
<span class="lineNum">     357 </span>                :            : // Helper functions that convert a Duration to an integral count of the
<span class="lineNum">     358 </span>                :            : // indicated unit. These functions are shorthand for the `IDivDuration()`
<span class="lineNum">     359 </span>                :            : // function above; see its documentation for details about overflow, etc.
<span class="lineNum">     360 </span>                :            : //
<span class="lineNum">     361 </span>                :            : // Example:
<span class="lineNum">     362 </span>                :            : //
<span class="lineNum">     363 </span>                :            : //   absl::Duration d = absl::Milliseconds(1500);
<span class="lineNum">     364 </span>                :            : //   int64_t isec = absl::ToInt64Seconds(d);  // isec == 1
<span class="lineNum">     365 </span>                :            : int64_t ToInt64Nanoseconds(Duration d);
<span class="lineNum">     366 </span>                :            : int64_t ToInt64Microseconds(Duration d);
<span class="lineNum">     367 </span>                :            : int64_t ToInt64Milliseconds(Duration d);
<span class="lineNum">     368 </span>                :            : int64_t ToInt64Seconds(Duration d);
<span class="lineNum">     369 </span>                :            : int64_t ToInt64Minutes(Duration d);
<span class="lineNum">     370 </span>                :            : int64_t ToInt64Hours(Duration d);
<span class="lineNum">     371 </span>                :            : 
<span class="lineNum">     372 </span>                :            : // ToDoubleNanoSeconds()
<span class="lineNum">     373 </span>                :            : // ToDoubleMicroseconds()
<span class="lineNum">     374 </span>                :            : // ToDoubleMilliseconds()
<span class="lineNum">     375 </span>                :            : // ToDoubleSeconds()
<span class="lineNum">     376 </span>                :            : // ToDoubleMinutes()
<span class="lineNum">     377 </span>                :            : // ToDoubleHours()
<span class="lineNum">     378 </span>                :            : //
<span class="lineNum">     379 </span>                :            : // Helper functions that convert a Duration to a floating point count of the
<span class="lineNum">     380 </span>                :            : // indicated unit. These functions are shorthand for the `FDivDuration()`
<span class="lineNum">     381 </span>                :            : // function above; see its documentation for details about overflow, etc.
<span class="lineNum">     382 </span>                :            : //
<span class="lineNum">     383 </span>                :            : // Example:
<span class="lineNum">     384 </span>                :            : //
<span class="lineNum">     385 </span>                :            : //   absl::Duration d = absl::Milliseconds(1500);
<span class="lineNum">     386 </span>                :            : //   double dsec = absl::ToDoubleSeconds(d);  // dsec == 1.5
<span class="lineNum">     387 </span>                :            : double ToDoubleNanoseconds(Duration d);
<span class="lineNum">     388 </span>                :            : double ToDoubleMicroseconds(Duration d);
<span class="lineNum">     389 </span>                :            : double ToDoubleMilliseconds(Duration d);
<span class="lineNum">     390 </span>                :            : double ToDoubleSeconds(Duration d);
<span class="lineNum">     391 </span>                :            : double ToDoubleMinutes(Duration d);
<span class="lineNum">     392 </span>                :            : double ToDoubleHours(Duration d);
<span class="lineNum">     393 </span>                :            : 
<span class="lineNum">     394 </span>                :            : // FromChrono()
<span class="lineNum">     395 </span>                :            : //
<span class="lineNum">     396 </span>                :            : // Converts any of the pre-defined std::chrono durations to an absl::Duration.
<span class="lineNum">     397 </span>                :            : //
<span class="lineNum">     398 </span>                :            : // Example:
<span class="lineNum">     399 </span>                :            : //
<span class="lineNum">     400 </span>                :            : //   std::chrono::milliseconds ms(123);
<span class="lineNum">     401 </span>                :            : //   absl::Duration d = absl::FromChrono(ms);
<span class="lineNum">     402 </span>                :            : constexpr Duration FromChrono(const std::chrono::nanoseconds&amp; d);
<span class="lineNum">     403 </span>                :            : constexpr Duration FromChrono(const std::chrono::microseconds&amp; d);
<span class="lineNum">     404 </span>                :            : constexpr Duration FromChrono(const std::chrono::milliseconds&amp; d);
<span class="lineNum">     405 </span>                :            : constexpr Duration FromChrono(const std::chrono::seconds&amp; d);
<span class="lineNum">     406 </span>                :            : constexpr Duration FromChrono(const std::chrono::minutes&amp; d);
<span class="lineNum">     407 </span>                :            : constexpr Duration FromChrono(const std::chrono::hours&amp; d);
<span class="lineNum">     408 </span>                :            : 
<span class="lineNum">     409 </span>                :            : // ToChronoNanoseconds()
<span class="lineNum">     410 </span>                :            : // ToChronoMicroseconds()
<span class="lineNum">     411 </span>                :            : // ToChronoMilliseconds()
<span class="lineNum">     412 </span>                :            : // ToChronoSeconds()
<span class="lineNum">     413 </span>                :            : // ToChronoMinutes()
<span class="lineNum">     414 </span>                :            : // ToChronoHours()
<span class="lineNum">     415 </span>                :            : //
<span class="lineNum">     416 </span>                :            : // Converts an absl::Duration to any of the pre-defined std::chrono durations.
<span class="lineNum">     417 </span>                :            : // If overflow would occur, the returned value will saturate at the min/max
<span class="lineNum">     418 </span>                :            : // chrono duration value instead.
<span class="lineNum">     419 </span>                :            : //
<span class="lineNum">     420 </span>                :            : // Example:
<span class="lineNum">     421 </span>                :            : //
<span class="lineNum">     422 </span>                :            : //   absl::Duration d = absl::Microseconds(123);
<span class="lineNum">     423 </span>                :            : //   auto x = absl::ToChronoMicroseconds(d);
<span class="lineNum">     424 </span>                :            : //   auto y = absl::ToChronoNanoseconds(d);  // x == y
<span class="lineNum">     425 </span>                :            : //   auto z = absl::ToChronoSeconds(absl::InfiniteDuration());
<span class="lineNum">     426 </span>                :            : //   // z == std::chrono::seconds::max()
<span class="lineNum">     427 </span>                :            : std::chrono::nanoseconds ToChronoNanoseconds(Duration d);
<span class="lineNum">     428 </span>                :            : std::chrono::microseconds ToChronoMicroseconds(Duration d);
<span class="lineNum">     429 </span>                :            : std::chrono::milliseconds ToChronoMilliseconds(Duration d);
<span class="lineNum">     430 </span>                :            : std::chrono::seconds ToChronoSeconds(Duration d);
<span class="lineNum">     431 </span>                :            : std::chrono::minutes ToChronoMinutes(Duration d);
<span class="lineNum">     432 </span>                :            : std::chrono::hours ToChronoHours(Duration d);
<span class="lineNum">     433 </span>                :            : 
<span class="lineNum">     434 </span>                :            : // InfiniteDuration()
<span class="lineNum">     435 </span>                :            : //
<span class="lineNum">     436 </span>                :            : // Returns an infinite `Duration`.  To get a `Duration` representing negative
<span class="lineNum">     437 </span>                :            : // infinity, use `-InfiniteDuration()`.
<span class="lineNum">     438 </span>                :            : //
<span class="lineNum">     439 </span>                :            : // Duration arithmetic overflows to +/- infinity and saturates. In general,
<span class="lineNum">     440 </span>                :            : // arithmetic with `Duration` infinities is similar to IEEE 754 infinities
<span class="lineNum">     441 </span>                :            : // except where IEEE 754 NaN would be involved, in which case +/-
<span class="lineNum">     442 </span>                :            : // `InfiniteDuration()` is used in place of a &quot;nan&quot; Duration.
<span class="lineNum">     443 </span>                :            : //
<span class="lineNum">     444 </span>                :            : // Examples:
<span class="lineNum">     445 </span>                :            : //
<span class="lineNum">     446 </span>                :            : //   constexpr absl::Duration inf = absl::InfiniteDuration();
<span class="lineNum">     447 </span>                :            : //   const absl::Duration d = ... any finite duration ...
<span class="lineNum">     448 </span>                :            : //
<span class="lineNum">     449 </span>                :            : //   inf == inf + inf
<span class="lineNum">     450 </span>                :            : //   inf == inf + d
<span class="lineNum">     451 </span>                :            : //   inf == inf - inf
<span class="lineNum">     452 </span>                :            : //   -inf == d - inf
<span class="lineNum">     453 </span>                :            : //
<span class="lineNum">     454 </span>                :            : //   inf == d * 1e100
<span class="lineNum">     455 </span>                :            : //   inf == inf / 2
<span class="lineNum">     456 </span>                :            : //   0 == d / inf
<span class="lineNum">     457 </span>                :            : //   INT64_MAX == inf / d
<span class="lineNum">     458 </span>                :            : //
<span class="lineNum">     459 </span>                :            : //   // Division by zero returns infinity, or INT64_MIN/MAX where appropriate.
<span class="lineNum">     460 </span>                :            : //   inf == d / 0
<span class="lineNum">     461 </span>                :            : //   INT64_MAX == d / absl::ZeroDuration()
<span class="lineNum">     462 </span>                :            : //
<span class="lineNum">     463 </span>                :            : // The examples involving the `/` operator above also apply to `IDivDuration()`
<span class="lineNum">     464 </span>                :            : // and `FDivDuration()`.
<span class="lineNum">     465 </span>                :            : constexpr Duration InfiniteDuration();
<span class="lineNum">     466 </span>                :            : 
<span class="lineNum">     467 </span>                :            : // FormatDuration()
<span class="lineNum">     468 </span>                :            : //
<span class="lineNum">     469 </span>                :            : // Returns a std::string representing the duration in the form &quot;72h3m0.5s&quot;.
<span class="lineNum">     470 </span>                :            : // Returns &quot;inf&quot; or &quot;-inf&quot; for +/- `InfiniteDuration()`.
<span class="lineNum">     471 </span>                :            : std::string FormatDuration(Duration d);
<span class="lineNum">     472 </span>                :            : 
<span class="lineNum">     473 </span>                :            : // Output stream operator.
<span class="lineNum">     474 </span>                :            : inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Duration d) {
<span class="lineNum">     475 </span>                :            :   return os &lt;&lt; FormatDuration(d);
<span class="lineNum">     476 </span>                :            : }
<span class="lineNum">     477 </span>                :            : 
<span class="lineNum">     478 </span>                :            : // ParseDuration()
<span class="lineNum">     479 </span>                :            : //
<span class="lineNum">     480 </span>                :            : // Parses a duration std::string consisting of a possibly signed sequence of
<span class="lineNum">     481 </span>                :            : // decimal numbers, each with an optional fractional part and a unit
<span class="lineNum">     482 </span>                :            : // suffix.  The valid suffixes are &quot;ns&quot;, &quot;us&quot; &quot;ms&quot;, &quot;s&quot;, &quot;m&quot;, and &quot;h&quot;.
<span class="lineNum">     483 </span>                :            : // Simple examples include &quot;300ms&quot;, &quot;-1.5h&quot;, and &quot;2h45m&quot;.  Parses &quot;0&quot; as
<span class="lineNum">     484 </span>                :            : // `ZeroDuration()`.  Parses &quot;inf&quot; and &quot;-inf&quot; as +/- `InfiniteDuration()`.
<span class="lineNum">     485 </span>                :            : bool ParseDuration(const std::string&amp; dur_string, Duration* d);
<span class="lineNum">     486 </span>                :            : 
<span class="lineNum">     487 </span>                :            : // Flag Support
<span class="lineNum">     488 </span>                :            : // TODO(absl-team): Remove once dependencies are removed.
<span class="lineNum">     489 </span>                :            : 
<span class="lineNum">     490 </span>                :            : // ParseFlag()
<span class="lineNum">     491 </span>                :            : //
<span class="lineNum">     492 </span>                :            : bool ParseFlag(const std::string&amp; text, Duration* dst, std::string* error);
<span class="lineNum">     493 </span>                :            : 
<span class="lineNum">     494 </span>                :            : // UnparseFlag()
<span class="lineNum">     495 </span>                :            : //
<span class="lineNum">     496 </span>                :            : std::string UnparseFlag(Duration d);
<span class="lineNum">     497 </span>                :            : 
<span class="lineNum">     498 </span>                :            : // Time
<span class="lineNum">     499 </span>                :            : //
<span class="lineNum">     500 </span>                :            : // An `absl::Time` represents a specific instant in time. Arithmetic operators
<span class="lineNum">     501 </span>                :            : // are provided for naturally expressing time calculations. Instances are
<span class="lineNum">     502 </span>                :            : // created using `absl::Now()` and the `absl::From*()` factory functions that
<span class="lineNum">     503 </span>                :            : // accept the gamut of other time representations. Formatting and parsing
<span class="lineNum">     504 </span>                :            : // functions are provided for conversion to and from strings.  `absl::Time`
<span class="lineNum">     505 </span>                :            : // should be passed by value rather than const reference.
<span class="lineNum">     506 </span>                :            : //
<span class="lineNum">     507 </span>                :            : // `absl::Time` assumes there are 60 seconds in a minute, which means the
<span class="lineNum">     508 </span>                :            : // underlying time scales must be &quot;smeared&quot; to eliminate leap seconds.
<span class="lineNum">     509 </span>                :            : // See https://developers.google.com/time/smear.
<span class="lineNum">     510 </span>                :            : //
<span class="lineNum">     511 </span>                :            : // Even though `absl::Time` supports a wide range of timestamps, exercise
<span class="lineNum">     512 </span>                :            : // caution when using values in the distant past. `absl::Time` uses the
<span class="lineNum">     513 </span>                :            : // Proleptic Gregorian calendar, which extends the Gregorian calendar backward
<span class="lineNum">     514 </span>                :            : // to dates before its introduction in 1582.
<span class="lineNum">     515 </span>                :            : // See https://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar
<span class="lineNum">     516 </span>                :            : // for more information. Use the ICU calendar classes to convert a date in
<span class="lineNum">     517 </span>                :            : // some other calendar (http://userguide.icu-project.org/datetime/calendar).
<span class="lineNum">     518 </span>                :            : //
<span class="lineNum">     519 </span>                :            : // Similarly, standardized time zones are a reasonably recent innovation, with
<span class="lineNum">     520 </span>                :            : // the Greenwich prime meridian being established in 1884. The TZ database
<span class="lineNum">     521 </span>                :            : // itself does not profess accurate offsets for timestamps prior to 1970. The
<span class="lineNum">     522 </span>                :            : // breakdown of future timestamps is subject to the whim of regional
<span class="lineNum">     523 </span>                :            : // governments.
<span class="lineNum">     524 </span>                :            : //
<span class="lineNum">     525 </span>                :            : // The `absl::Time` class represents an instant in time as a count of clock
<span class="lineNum">     526 </span>                :            : // ticks of some granularity (resolution) from some starting point (epoch).
<span class="lineNum">     527 </span>                :            : //
<span class="lineNum">     528 </span>                :            : //
<span class="lineNum">     529 </span>                :            : // `absl::Time` uses a resolution that is high enough to avoid loss in
<span class="lineNum">     530 </span>                :            : // precision, and a range that is wide enough to avoid overflow, when
<span class="lineNum">     531 </span>                :            : // converting between tick counts in most Google time scales (i.e., precision
<span class="lineNum">     532 </span>                :            : // of at least one nanosecond, and range +/-100 billion years).  Conversions
<span class="lineNum">     533 </span>                :            : // between the time scales are performed by truncating (towards negative
<span class="lineNum">     534 </span>                :            : // infinity) to the nearest representable point.
<span class="lineNum">     535 </span>                :            : //
<span class="lineNum">     536 </span>                :            : // Examples:
<span class="lineNum">     537 </span>                :            : //
<span class="lineNum">     538 </span>                :            : //   absl::Time t1 = ...;
<span class="lineNum">     539 </span>                :            : //   absl::Time t2 = t1 + absl::Minutes(2);
<span class="lineNum">     540 </span>                :            : //   absl::Duration d = t2 - t1;  // == absl::Minutes(2)
<span class="lineNum">     541 </span>                :            : //   absl::Time::Breakdown bd = t1.In(absl::LocalTimeZone());
<span class="lineNum">     542 </span>                :            : //
<span class="lineNum">     543 </span>                :            : class Time {
<span class="lineNum">     544 </span>                :            :  public:
<span class="lineNum">     545 </span>                :            :   // Value semantics.
<span class="lineNum">     546 </span>                :            : 
<span class="lineNum">     547 </span>                :            :   // Returns the Unix epoch.  However, those reading your code may not know
<span class="lineNum">     548 </span>                :            :   // or expect the Unix epoch as the default value, so make your code more
<span class="lineNum">     549 </span>                :            :   // readable by explicitly initializing all instances before use.
<span class="lineNum">     550 </span>                :            :   //
<span class="lineNum">     551 </span>                :            :   // Example:
<span class="lineNum">     552 </span>                :            :   //   absl::Time t = absl::UnixEpoch();
<span class="lineNum">     553 </span>                :            :   //   absl::Time t = absl::Now();
<span class="lineNum">     554 </span>                :            :   //   absl::Time t = absl::TimeFromTimeval(tv);
<span class="lineNum">     555 </span>                :            :   //   absl::Time t = absl::InfinitePast();
<span class="lineNum">     556 </span>                :            :   constexpr Time() {}
<span class="lineNum">     557 </span>                :            : 
<span class="lineNum">     558 </span>                :            :   // Assignment operators.
<span class="lineNum">     559 </span>                :            :   Time&amp; operator+=(Duration d) {
<span class="lineNum">     560 </span>                :            :     rep_ += d;
<span class="lineNum">     561 </span>                :            :     return *this;
<span class="lineNum">     562 </span>                :            :   }
<span class="lineNum">     563 </span>                :            :   Time&amp; operator-=(Duration d) {
<span class="lineNum">     564 </span>                :            :     rep_ -= d;
<span class="lineNum">     565 </span>                :            :     return *this;
<span class="lineNum">     566 </span>                :            :   }
<span class="lineNum">     567 </span>                :            : 
<span class="lineNum">     568 </span>                :            :   // Time::Breakdown
<span class="lineNum">     569 </span>                :            :   //
<span class="lineNum">     570 </span>                :            :   // The calendar and wall-clock (aka &quot;civil time&quot;) components of an
<span class="lineNum">     571 </span>                :            :   // `absl::Time` in a certain `absl::TimeZone`. This struct is not
<span class="lineNum">     572 </span>                :            :   // intended to represent an instant in time. So, rather than passing
<span class="lineNum">     573 </span>                :            :   // a `Time::Breakdown` to a function, pass an `absl::Time` and an
<span class="lineNum">     574 </span>                :            :   // `absl::TimeZone`.
<span class="lineNum">     575 </span>                :            :   struct Breakdown {
<span class="lineNum">     576 </span>                :            :     int64_t year;          // year (e.g., 2013)
<span class="lineNum">     577 </span>                :            :     int month;           // month of year [1:12]
<span class="lineNum">     578 </span>                :            :     int day;             // day of month [1:31]
<span class="lineNum">     579 </span>                :            :     int hour;            // hour of day [0:23]
<span class="lineNum">     580 </span>                :            :     int minute;          // minute of hour [0:59]
<span class="lineNum">     581 </span>                :            :     int second;          // second of minute [0:59]
<span class="lineNum">     582 </span>                :            :     Duration subsecond;  // [Seconds(0):Seconds(1)) if finite
<span class="lineNum">     583 </span>                :            :     int weekday;         // 1==Mon, ..., 7=Sun
<span class="lineNum">     584 </span>                :            :     int yearday;         // day of year [1:366]
<span class="lineNum">     585 </span>                :            : 
<span class="lineNum">     586 </span>                :            :     // Note: The following fields exist for backward compatibility
<span class="lineNum">     587 </span>                :            :     // with older APIs.  Accessing these fields directly is a sign of
<span class="lineNum">     588 </span>                :            :     // imprudent logic in the calling code.  Modern time-related code
<span class="lineNum">     589 </span>                :            :     // should only access this data indirectly by way of FormatTime().
<span class="lineNum">     590 </span>                :            :     // These fields are undefined for InfiniteFuture() and InfinitePast().
<span class="lineNum">     591 </span>                :            :     int offset;             // seconds east of UTC
<span class="lineNum">     592 </span>                :            :     bool is_dst;            // is offset non-standard?
<span class="lineNum">     593 </span>                :            :     const char* zone_abbr;  // time-zone abbreviation (e.g., &quot;PST&quot;)
<span class="lineNum">     594 </span>                :            :   };
<span class="lineNum">     595 </span>                :            : 
<span class="lineNum">     596 </span>                :            :   // Time::In()
<span class="lineNum">     597 </span>                :            :   //
<span class="lineNum">     598 </span>                :            :   // Returns the breakdown of this instant in the given TimeZone.
<span class="lineNum">     599 </span>                :            :   Breakdown In(TimeZone tz) const;
<span class="lineNum">     600 </span>                :            : 
<span class="lineNum">     601 </span>                :            :  private:
<span class="lineNum">     602 </span>                :            :   friend constexpr Time time_internal::FromUnixDuration(Duration d);
<span class="lineNum">     603 </span>                :            :   friend constexpr Duration time_internal::ToUnixDuration(Time t);
<span class="lineNum">     604 </span>                :            :   friend constexpr bool operator&lt;(Time lhs, Time rhs);
<span class="lineNum">     605 </span>                :            :   friend constexpr bool operator==(Time lhs, Time rhs);
<span class="lineNum">     606 </span>                :            :   friend Duration operator-(Time lhs, Time rhs);
<span class="lineNum">     607 </span>                :            :   friend constexpr Time UniversalEpoch();
<a name="608"><span class="lineNum">     608 </span>                :            :   friend constexpr Time InfiniteFuture();</a>
<span class="lineNum">     609 </span>                :            :   friend constexpr Time InfinitePast();
<span class="lineNum">     610 </span>                :<span class="lineCov">         35 :   constexpr explicit Time(Duration rep) : rep_(rep) {}</span>
<span class="lineNum">     611 </span>                :            :   Duration rep_;
<span class="lineNum">     612 </span>                :            : };
<a name="613"><span class="lineNum">     613 </span>                :            : </a>
<span class="lineNum">     614 </span>                :            : // Relational Operators
<a name="615"><span class="lineNum">     615 </span>                :<span class="lineNoCov">          0 : constexpr bool operator&lt;(Time lhs, Time rhs) { return lhs.rep_ &lt; rhs.rep_; }</span></a>
<span class="lineNum">     616 </span>                :            : constexpr bool operator&gt;(Time lhs, Time rhs) { return rhs &lt; lhs; }
<span class="lineNum">     617 </span>                :<span class="lineNoCov">          0 : constexpr bool operator&gt;=(Time lhs, Time rhs) { return !(lhs &lt; rhs); }</span>
<span class="lineNum">     618 </span>                :            : constexpr bool operator&lt;=(Time lhs, Time rhs) { return !(rhs &lt; lhs); }
<span class="lineNum">     619 </span>                :            : constexpr bool operator==(Time lhs, Time rhs) { return lhs.rep_ == rhs.rep_; }
<span class="lineNum">     620 </span>                :            : constexpr bool operator!=(Time lhs, Time rhs) { return !(lhs == rhs); }
<span class="lineNum">     621 </span>                :            : 
<span class="lineNum">     622 </span>                :            : // Additive Operators
<span class="lineNum">     623 </span>                :            : inline Time operator+(Time lhs, Duration rhs) { return lhs += rhs; }
<a name="624"><span class="lineNum">     624 </span>                :            : inline Time operator+(Duration lhs, Time rhs) { return rhs += lhs; }</a>
<span class="lineNum">     625 </span>                :            : inline Time operator-(Time lhs, Duration rhs) { return lhs -= rhs; }
<span class="lineNum">     626 </span>                :<span class="lineNoCov">          0 : inline Duration operator-(Time lhs, Time rhs) { return lhs.rep_ - rhs.rep_; }</span>
<span class="lineNum">     627 </span>                :            : 
<span class="lineNum">     628 </span>                :            : // UnixEpoch()
<span class="lineNum">     629 </span>                :            : //
<span class="lineNum">     630 </span>                :            : // Returns the `absl::Time` representing &quot;1970-01-01 00:00:00.0 +0000&quot;.
<span class="lineNum">     631 </span>                :            : constexpr Time UnixEpoch() { return Time(); }
<span class="lineNum">     632 </span>                :            : 
<span class="lineNum">     633 </span>                :            : // UniversalEpoch()
<span class="lineNum">     634 </span>                :            : //
<span class="lineNum">     635 </span>                :            : // Returns the `absl::Time` representing &quot;0001-01-01 00:00:00.0 +0000&quot;, the
<span class="lineNum">     636 </span>                :            : // epoch of the ICU Universal Time Scale.
<span class="lineNum">     637 </span>                :            : constexpr Time UniversalEpoch() {
<span class="lineNum">     638 </span>                :            :   // 719162 is the number of days from 0001-01-01 to 1970-01-01,
<span class="lineNum">     639 </span>                :            :   // assuming the Gregorian calendar.
<span class="lineNum">     640 </span>                :            :   return Time(time_internal::MakeDuration(-24 * 719162 * int64_t{3600}, 0U));
<span class="lineNum">     641 </span>                :            : }
<span class="lineNum">     642 </span>                :            : 
<span class="lineNum">     643 </span>                :            : // InfiniteFuture()
<span class="lineNum">     644 </span>                :            : //
<span class="lineNum">     645 </span>                :            : // Returns an `absl::Time` that is infinitely far in the future.
<span class="lineNum">     646 </span>                :            : constexpr Time InfiniteFuture() {
<span class="lineNum">     647 </span>                :            :   return Time(
<span class="lineNum">     648 </span>                :            :       time_internal::MakeDuration(std::numeric_limits&lt;int64_t&gt;::max(), ~0U));
<span class="lineNum">     649 </span>                :            : }
<span class="lineNum">     650 </span>                :            : 
<span class="lineNum">     651 </span>                :            : // InfinitePast()
<span class="lineNum">     652 </span>                :            : //
<span class="lineNum">     653 </span>                :            : // Returns an `absl::Time` that is infinitely far in the past.
<span class="lineNum">     654 </span>                :            : constexpr Time InfinitePast() {
<span class="lineNum">     655 </span>                :            :   return Time(
<span class="lineNum">     656 </span>                :            :       time_internal::MakeDuration(std::numeric_limits&lt;int64_t&gt;::min(), ~0U));
<span class="lineNum">     657 </span>                :            : }
<span class="lineNum">     658 </span>                :            : 
<span class="lineNum">     659 </span>                :            : // TimeConversion
<span class="lineNum">     660 </span>                :            : //
<span class="lineNum">     661 </span>                :            : // An `absl::TimeConversion` represents the conversion of year, month, day,
<span class="lineNum">     662 </span>                :            : // hour, minute, and second values (i.e., a civil time), in a particular
<span class="lineNum">     663 </span>                :            : // `absl::TimeZone`, to a time instant (an absolute time), as returned by
<span class="lineNum">     664 </span>                :            : // `absl::ConvertDateTime()`. (Subseconds must be handled separately.)
<span class="lineNum">     665 </span>                :            : //
<span class="lineNum">     666 </span>                :            : // It is possible, though, for a caller to try to convert values that
<span class="lineNum">     667 </span>                :            : // do not represent an actual or unique instant in time (due to a shift
<span class="lineNum">     668 </span>                :            : // in UTC offset in the `absl::TimeZone`, which results in a discontinuity in
<span class="lineNum">     669 </span>                :            : // the civil-time components). For example, a daylight-saving-time
<span class="lineNum">     670 </span>                :            : // transition skips or repeats civil times---in the United States, March
<span class="lineNum">     671 </span>                :            : // 13, 2011 02:15 never occurred, while November 6, 2011 01:15 occurred
<span class="lineNum">     672 </span>                :            : // twice---so requests for such times are not well-defined.
<span class="lineNum">     673 </span>                :            : //
<span class="lineNum">     674 </span>                :            : // To account for these possibilities, `absl::TimeConversion` is richer
<span class="lineNum">     675 </span>                :            : // than just a single `absl::Time`. When the civil time is skipped or
<span class="lineNum">     676 </span>                :            : // repeated, `absl::ConvertDateTime()` returns times calculated using the
<span class="lineNum">     677 </span>                :            : // pre-transition and post-transition UTC offsets, plus the transition
<span class="lineNum">     678 </span>                :            : // time itself.
<span class="lineNum">     679 </span>                :            : //
<span class="lineNum">     680 </span>                :            : // Examples:
<span class="lineNum">     681 </span>                :            : //
<span class="lineNum">     682 </span>                :            : //   absl::TimeZone lax;
<span class="lineNum">     683 </span>                :            : //   if (!absl::LoadTimeZone(&quot;America/Los_Angeles&quot;, &amp;lax)) { ... }
<span class="lineNum">     684 </span>                :            : //
<span class="lineNum">     685 </span>                :            : //   // A unique civil time
<span class="lineNum">     686 </span>                :            : //   absl::TimeConversion jan01 =
<span class="lineNum">     687 </span>                :            : //       absl::ConvertDateTime(2011, 1, 1, 0, 0, 0, lax);
<span class="lineNum">     688 </span>                :            : //   // jan01.kind == TimeConversion::UNIQUE
<span class="lineNum">     689 </span>                :            : //   // jan01.pre    is 2011/01/01 00:00:00 -0800
<span class="lineNum">     690 </span>                :            : //   // jan01.trans  is 2011/01/01 00:00:00 -0800
<span class="lineNum">     691 </span>                :            : //   // jan01.post   is 2011/01/01 00:00:00 -0800
<span class="lineNum">     692 </span>                :            : //
<span class="lineNum">     693 </span>                :            : //   // A Spring DST transition, when there is a gap in civil time
<span class="lineNum">     694 </span>                :            : //   absl::TimeConversion mar13 =
<span class="lineNum">     695 </span>                :            : //       absl::ConvertDateTime(2011, 3, 13, 2, 15, 0, lax);
<span class="lineNum">     696 </span>                :            : //   // mar13.kind == TimeConversion::SKIPPED
<span class="lineNum">     697 </span>                :            : //   // mar13.pre   is 2011/03/13 03:15:00 -0700
<span class="lineNum">     698 </span>                :            : //   // mar13.trans is 2011/03/13 03:00:00 -0700
<span class="lineNum">     699 </span>                :            : //   // mar13.post  is 2011/03/13 01:15:00 -0800
<span class="lineNum">     700 </span>                :            : //
<span class="lineNum">     701 </span>                :            : //   // A Fall DST transition, when civil times are repeated
<span class="lineNum">     702 </span>                :            : //   absl::TimeConversion nov06 =
<span class="lineNum">     703 </span>                :            : //       absl::ConvertDateTime(2011, 11, 6, 1, 15, 0, lax);
<span class="lineNum">     704 </span>                :            : //   // nov06.kind == TimeConversion::REPEATED
<span class="lineNum">     705 </span>                :            : //   // nov06.pre   is 2011/11/06 01:15:00 -0700
<span class="lineNum">     706 </span>                :            : //   // nov06.trans is 2011/11/06 01:00:00 -0800
<span class="lineNum">     707 </span>                :            : //   // nov06.post  is 2011/11/06 01:15:00 -0800
<span class="lineNum">     708 </span>                :            : //
<span class="lineNum">     709 </span>                :            : // The input month, day, hour, minute, and second values can also be
<span class="lineNum">     710 </span>                :            : // outside of their valid ranges, in which case they will be &quot;normalized&quot;
<span class="lineNum">     711 </span>                :            : // during the conversion.
<span class="lineNum">     712 </span>                :            : //
<span class="lineNum">     713 </span>                :            : // Example:
<span class="lineNum">     714 </span>                :            : //
<span class="lineNum">     715 </span>                :            : //   // &quot;October 32&quot; normalizes to &quot;November 1&quot;.
<span class="lineNum">     716 </span>                :            : //   absl::TimeZone tz = absl::LocalTimeZone();
<span class="lineNum">     717 </span>                :            : //   absl::TimeConversion tc =
<span class="lineNum">     718 </span>                :            : //       absl::ConvertDateTime(2013, 10, 32, 8, 30, 0, tz);
<span class="lineNum">     719 </span>                :            : //   // tc.kind == TimeConversion::UNIQUE &amp;&amp; tc.normalized == true
<span class="lineNum">     720 </span>                :            : //   // tc.pre.In(tz).month == 11 &amp;&amp; tc.pre.In(tz).day == 1
<span class="lineNum">     721 </span>                :            : struct TimeConversion {
<span class="lineNum">     722 </span>                :            :   Time pre;    // time calculated using the pre-transition offset
<span class="lineNum">     723 </span>                :            :   Time trans;  // when the civil-time discontinuity occurred
<span class="lineNum">     724 </span>                :            :   Time post;   // time calculated using the post-transition offset
<span class="lineNum">     725 </span>                :            : 
<span class="lineNum">     726 </span>                :            :   enum Kind {
<span class="lineNum">     727 </span>                :            :     UNIQUE,    // the civil time was singular (pre == trans == post)
<span class="lineNum">     728 </span>                :            :     SKIPPED,   // the civil time did not exist
<span class="lineNum">     729 </span>                :            :     REPEATED,  // the civil time was ambiguous
<span class="lineNum">     730 </span>                :            :   };
<span class="lineNum">     731 </span>                :            :   Kind kind;
<span class="lineNum">     732 </span>                :            : 
<span class="lineNum">     733 </span>                :            :   bool normalized;  // input values were outside their valid ranges
<span class="lineNum">     734 </span>                :            : };
<span class="lineNum">     735 </span>                :            : 
<span class="lineNum">     736 </span>                :            : // ConvertDateTime()
<span class="lineNum">     737 </span>                :            : //
<span class="lineNum">     738 </span>                :            : // The full generality of a civil time to absl::Time conversion.
<span class="lineNum">     739 </span>                :            : TimeConversion ConvertDateTime(int64_t year, int mon, int day, int hour,
<span class="lineNum">     740 </span>                :            :                                int min, int sec, TimeZone tz);
<span class="lineNum">     741 </span>                :            : 
<span class="lineNum">     742 </span>                :            : // FromDateTime()
<span class="lineNum">     743 </span>                :            : //
<span class="lineNum">     744 </span>                :            : // A convenience wrapper for `absl::ConvertDateTime()` that simply returns the
<span class="lineNum">     745 </span>                :            : // &quot;pre&quot; `absl::Time`.  That is, the unique result, or the instant that
<span class="lineNum">     746 </span>                :            : // is correct using the pre-transition offset (as if the transition
<span class="lineNum">     747 </span>                :            : // never happened). This is typically the answer that humans expected when
<span class="lineNum">     748 </span>                :            : // faced with non-unique times, such as near daylight-saving time transitions.
<span class="lineNum">     749 </span>                :            : //
<span class="lineNum">     750 </span>                :            : // Example:
<span class="lineNum">     751 </span>                :            : //
<span class="lineNum">     752 </span>                :            : //   absl::TimeZone seattle;
<span class="lineNum">     753 </span>                :            : //   if (!absl::LoadTimeZone(&quot;America/Los_Angeles&quot;, &amp;seattle)) { ... }
<span class="lineNum">     754 </span>                :            : //   absl::Time t =  absl::FromDateTime(2017, 9, 26, 9, 30, 0, seattle);
<span class="lineNum">     755 </span>                :            : Time FromDateTime(int64_t year, int mon, int day, int hour, int min, int sec,
<span class="lineNum">     756 </span>                :            :                   TimeZone tz);
<span class="lineNum">     757 </span>                :            : 
<span class="lineNum">     758 </span>                :            : // FromTM()
<span class="lineNum">     759 </span>                :            : //
<span class="lineNum">     760 </span>                :            : // Converts the `tm_year`, `tm_mon`, `tm_mday`, `tm_hour`, `tm_min`, and
<span class="lineNum">     761 </span>                :            : // `tm_sec` fields to an `absl::Time` using the given time zone. See ctime(3)
<span class="lineNum">     762 </span>                :            : // for a description of the expected values of the tm fields. IFF the indicated
<span class="lineNum">     763 </span>                :            : // time instant is not unique (see `absl::ConvertDateTime()` above), the
<span class="lineNum">     764 </span>                :            : // `tm_isdst` field is consulted to select the desired instant (`tm_isdst` &gt; 0
<span class="lineNum">     765 </span>                :            : // means DST, `tm_isdst` == 0 means no DST, `tm_isdst` &lt; 0 means use the default
<span class="lineNum">     766 </span>                :            : // like `absl::FromDateTime()`).
<span class="lineNum">     767 </span>                :            : Time FromTM(const struct tm&amp; tm, TimeZone tz);
<span class="lineNum">     768 </span>                :            : 
<span class="lineNum">     769 </span>                :            : // ToTM()
<span class="lineNum">     770 </span>                :            : //
<span class="lineNum">     771 </span>                :            : // Converts the given `absl::Time` to a struct tm using the given time zone.
<span class="lineNum">     772 </span>                :            : // See ctime(3) for a description of the values of the tm fields.
<span class="lineNum">     773 </span>                :            : struct tm ToTM(Time t, TimeZone tz);
<span class="lineNum">     774 </span>                :            : 
<span class="lineNum">     775 </span>                :            : // FromUnixNanos()
<span class="lineNum">     776 </span>                :            : // FromUnixMicros()
<span class="lineNum">     777 </span>                :            : // FromUnixMillis()
<span class="lineNum">     778 </span>                :            : // FromUnixSeconds()
<span class="lineNum">     779 </span>                :            : // FromTimeT()
<span class="lineNum">     780 </span>                :            : // FromUDate()
<span class="lineNum">     781 </span>                :            : // FromUniversal()
<span class="lineNum">     782 </span>                :            : //
<span class="lineNum">     783 </span>                :            : // Creates an `absl::Time` from a variety of other representations.
<span class="lineNum">     784 </span>                :            : constexpr Time FromUnixNanos(int64_t ns);
<span class="lineNum">     785 </span>                :            : constexpr Time FromUnixMicros(int64_t us);
<span class="lineNum">     786 </span>                :            : constexpr Time FromUnixMillis(int64_t ms);
<span class="lineNum">     787 </span>                :            : constexpr Time FromUnixSeconds(int64_t s);
<span class="lineNum">     788 </span>                :            : constexpr Time FromTimeT(time_t t);
<span class="lineNum">     789 </span>                :            : Time FromUDate(double udate);
<span class="lineNum">     790 </span>                :            : Time FromUniversal(int64_t universal);
<span class="lineNum">     791 </span>                :            : 
<span class="lineNum">     792 </span>                :            : // ToUnixNanos()
<span class="lineNum">     793 </span>                :            : // ToUnixMicros()
<span class="lineNum">     794 </span>                :            : // ToUnixMillis()
<span class="lineNum">     795 </span>                :            : // ToUnixSeconds()
<span class="lineNum">     796 </span>                :            : // ToTimeT()
<span class="lineNum">     797 </span>                :            : // ToUDate()
<span class="lineNum">     798 </span>                :            : // ToUniversal()
<span class="lineNum">     799 </span>                :            : //
<span class="lineNum">     800 </span>                :            : // Converts an `absl::Time` to a variety of other representations.  Note that
<span class="lineNum">     801 </span>                :            : // these operations round down toward negative infinity where necessary to
<span class="lineNum">     802 </span>                :            : // adjust to the resolution of the result type.  Beware of possible time_t
<span class="lineNum">     803 </span>                :            : // over/underflow in ToTime{T,val,spec}() on 32-bit platforms.
<span class="lineNum">     804 </span>                :            : int64_t ToUnixNanos(Time t);
<span class="lineNum">     805 </span>                :            : int64_t ToUnixMicros(Time t);
<span class="lineNum">     806 </span>                :            : int64_t ToUnixMillis(Time t);
<span class="lineNum">     807 </span>                :            : int64_t ToUnixSeconds(Time t);
<span class="lineNum">     808 </span>                :            : time_t ToTimeT(Time t);
<span class="lineNum">     809 </span>                :            : double ToUDate(Time t);
<span class="lineNum">     810 </span>                :            : int64_t ToUniversal(Time t);
<span class="lineNum">     811 </span>                :            : 
<span class="lineNum">     812 </span>                :            : // DurationFromTimespec()
<span class="lineNum">     813 </span>                :            : // DurationFromTimeval()
<span class="lineNum">     814 </span>                :            : // ToTimespec()
<span class="lineNum">     815 </span>                :            : // ToTimeval()
<span class="lineNum">     816 </span>                :            : // TimeFromTimespec()
<span class="lineNum">     817 </span>                :            : // TimeFromTimeval()
<span class="lineNum">     818 </span>                :            : // ToTimespec()
<span class="lineNum">     819 </span>                :            : // ToTimeval()
<span class="lineNum">     820 </span>                :            : //
<span class="lineNum">     821 </span>                :            : // Some APIs use a timespec or a timeval as a Duration (e.g., nanosleep(2)
<span class="lineNum">     822 </span>                :            : // and select(2)), while others use them as a Time (e.g. clock_gettime(2)
<span class="lineNum">     823 </span>                :            : // and gettimeofday(2)), so conversion functions are provided for both cases.
<span class="lineNum">     824 </span>                :            : // The &quot;to timespec/val&quot; direction is easily handled via overloading, but
<span class="lineNum">     825 </span>                :            : // for &quot;from timespec/val&quot; the desired type is part of the function name.
<span class="lineNum">     826 </span>                :            : Duration DurationFromTimespec(timespec ts);
<span class="lineNum">     827 </span>                :            : Duration DurationFromTimeval(timeval tv);
<span class="lineNum">     828 </span>                :            : timespec ToTimespec(Duration d);
<span class="lineNum">     829 </span>                :            : timeval ToTimeval(Duration d);
<span class="lineNum">     830 </span>                :            : Time TimeFromTimespec(timespec ts);
<span class="lineNum">     831 </span>                :            : Time TimeFromTimeval(timeval tv);
<span class="lineNum">     832 </span>                :            : timespec ToTimespec(Time t);
<span class="lineNum">     833 </span>                :            : timeval ToTimeval(Time t);
<span class="lineNum">     834 </span>                :            : 
<span class="lineNum">     835 </span>                :            : // FromChrono()
<span class="lineNum">     836 </span>                :            : //
<span class="lineNum">     837 </span>                :            : // Converts a std::chrono::system_clock::time_point to an absl::Time.
<span class="lineNum">     838 </span>                :            : //
<span class="lineNum">     839 </span>                :            : // Example:
<span class="lineNum">     840 </span>                :            : //
<span class="lineNum">     841 </span>                :            : //   auto tp = std::chrono::system_clock::from_time_t(123);
<span class="lineNum">     842 </span>                :            : //   absl::Time t = absl::FromChrono(tp);
<span class="lineNum">     843 </span>                :            : //   // t == absl::FromTimeT(123)
<span class="lineNum">     844 </span>                :            : Time FromChrono(const std::chrono::system_clock::time_point&amp; tp);
<span class="lineNum">     845 </span>                :            : 
<span class="lineNum">     846 </span>                :            : // ToChronoTime()
<span class="lineNum">     847 </span>                :            : //
<span class="lineNum">     848 </span>                :            : // Converts an absl::Time to a std::chrono::system_clock::time_point. If
<span class="lineNum">     849 </span>                :            : // overflow would occur, the returned value will saturate at the min/max time
<span class="lineNum">     850 </span>                :            : // point value instead.
<span class="lineNum">     851 </span>                :            : //
<span class="lineNum">     852 </span>                :            : // Example:
<span class="lineNum">     853 </span>                :            : //
<span class="lineNum">     854 </span>                :            : //   absl::Time t = absl::FromTimeT(123);
<span class="lineNum">     855 </span>                :            : //   auto tp = absl::ToChronoTime(t);
<span class="lineNum">     856 </span>                :            : //   // tp == std::chrono::system_clock::from_time_t(123);
<span class="lineNum">     857 </span>                :            : std::chrono::system_clock::time_point ToChronoTime(Time);
<span class="lineNum">     858 </span>                :            : 
<span class="lineNum">     859 </span>                :            : // RFC3339_full
<span class="lineNum">     860 </span>                :            : // RFC3339_sec
<span class="lineNum">     861 </span>                :            : //
<span class="lineNum">     862 </span>                :            : // FormatTime()/ParseTime() format specifiers for RFC3339 date/time strings,
<span class="lineNum">     863 </span>                :            : // with trailing zeros trimmed or with fractional seconds omitted altogether.
<span class="lineNum">     864 </span>                :            : //
<span class="lineNum">     865 </span>                :            : // Note that RFC3339_sec[] matches an ISO 8601 extended format for date
<span class="lineNum">     866 </span>                :            : // and time with UTC offset.
<span class="lineNum">     867 </span>                :            : extern const char RFC3339_full[];  // %Y-%m-%dT%H:%M:%E*S%Ez
<span class="lineNum">     868 </span>                :            : extern const char RFC3339_sec[];   // %Y-%m-%dT%H:%M:%S%Ez
<span class="lineNum">     869 </span>                :            : 
<span class="lineNum">     870 </span>                :            : // RFC1123_full
<span class="lineNum">     871 </span>                :            : // RFC1123_no_wday
<span class="lineNum">     872 </span>                :            : //
<span class="lineNum">     873 </span>                :            : // FormatTime()/ParseTime() format specifiers for RFC1123 date/time strings.
<span class="lineNum">     874 </span>                :            : extern const char RFC1123_full[];     // %a, %d %b %E4Y %H:%M:%S %z
<span class="lineNum">     875 </span>                :            : extern const char RFC1123_no_wday[];  // %d %b %E4Y %H:%M:%S %z
<span class="lineNum">     876 </span>                :            : 
<span class="lineNum">     877 </span>                :            : // FormatTime()
<span class="lineNum">     878 </span>                :            : //
<span class="lineNum">     879 </span>                :            : // Formats the given `absl::Time` in the `absl::TimeZone` according to the
<span class="lineNum">     880 </span>                :            : // provided format std::string. Uses strftime()-like formatting options, with
<span class="lineNum">     881 </span>                :            : // the following extensions:
<span class="lineNum">     882 </span>                :            : //
<span class="lineNum">     883 </span>                :            : //   - %Ez  - RFC3339-compatible numeric UTC offset (+hh:mm or -hh:mm)
<span class="lineNum">     884 </span>                :            : //   - %E*z - Full-resolution numeric UTC offset (+hh:mm:ss or -hh:mm:ss)
<span class="lineNum">     885 </span>                :            : //   - %E#S - Seconds with # digits of fractional precision
<span class="lineNum">     886 </span>                :            : //   - %E*S - Seconds with full fractional precision (a literal '*')
<span class="lineNum">     887 </span>                :            : //   - %E#f - Fractional seconds with # digits of precision
<span class="lineNum">     888 </span>                :            : //   - %E*f - Fractional seconds with full precision (a literal '*')
<span class="lineNum">     889 </span>                :            : //   - %E4Y - Four-character years (-999 ... -001, 0000, 0001 ... 9999)
<span class="lineNum">     890 </span>                :            : //
<span class="lineNum">     891 </span>                :            : // Note that %E0S behaves like %S, and %E0f produces no characters.  In
<span class="lineNum">     892 </span>                :            : // contrast %E*f always produces at least one digit, which may be '0'.
<span class="lineNum">     893 </span>                :            : //
<span class="lineNum">     894 </span>                :            : // Note that %Y produces as many characters as it takes to fully render the
<span class="lineNum">     895 </span>                :            : // year.  A year outside of [-999:9999] when formatted with %E4Y will produce
<span class="lineNum">     896 </span>                :            : // more than four characters, just like %Y.
<span class="lineNum">     897 </span>                :            : //
<span class="lineNum">     898 </span>                :            : // We recommend that format strings include the UTC offset (%z, %Ez, or %E*z)
<span class="lineNum">     899 </span>                :            : // so that the result uniquely identifies a time instant.
<span class="lineNum">     900 </span>                :            : //
<span class="lineNum">     901 </span>                :            : // Example:
<span class="lineNum">     902 </span>                :            : //
<span class="lineNum">     903 </span>                :            : //   absl::TimeZone lax;
<span class="lineNum">     904 </span>                :            : //   if (!absl::LoadTimeZone(&quot;America/Los_Angeles&quot;, &amp;lax)) { ... }
<span class="lineNum">     905 </span>                :            : //   absl::Time t = absl::FromDateTime(2013, 1, 2, 3, 4, 5, lax);
<span class="lineNum">     906 </span>                :            : //
<span class="lineNum">     907 </span>                :            : //   std::string f = absl::FormatTime(&quot;%H:%M:%S&quot;, t, lax);  // &quot;03:04:05&quot;
<span class="lineNum">     908 </span>                :            : //   f = absl::FormatTime(&quot;%H:%M:%E3S&quot;, t, lax);  // &quot;03:04:05.000&quot;
<span class="lineNum">     909 </span>                :            : //
<span class="lineNum">     910 </span>                :            : // Note: If the given `absl::Time` is `absl::InfiniteFuture()`, the returned
<span class="lineNum">     911 </span>                :            : // std::string will be exactly &quot;infinite-future&quot;. If the given `absl::Time` is
<span class="lineNum">     912 </span>                :            : // `absl::InfinitePast()`, the returned std::string will be exactly &quot;infinite-past&quot;.
<span class="lineNum">     913 </span>                :            : // In both cases the given format std::string and `absl::TimeZone` are ignored.
<span class="lineNum">     914 </span>                :            : //
<span class="lineNum">     915 </span>                :            : std::string FormatTime(const std::string&amp; format, Time t, TimeZone tz);
<span class="lineNum">     916 </span>                :            : 
<span class="lineNum">     917 </span>                :            : // Convenience functions that format the given time using the RFC3339_full
<span class="lineNum">     918 </span>                :            : // format.  The first overload uses the provided TimeZone, while the second
<span class="lineNum">     919 </span>                :            : // uses LocalTimeZone().
<span class="lineNum">     920 </span>                :            : std::string FormatTime(Time t, TimeZone tz);
<span class="lineNum">     921 </span>                :            : std::string FormatTime(Time t);
<a name="922"><span class="lineNum">     922 </span>                :            : </a>
<span class="lineNum">     923 </span>                :            : // Output stream operator.
<span class="lineNum">     924 </span>                :<span class="lineNoCov">          0 : inline std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, Time t) {</span>
<span class="lineNum">     925 </span>        [<span class="branchNoExec" title="Branch 2 was not executed"> # </span><span class="branchNoExec" title="Branch 3 was not executed"> # </span>]:<span class="lineNoCov">          0 :   return os &lt;&lt; FormatTime(t);</span>
<span class="lineNum">     926 </span>                :            : }
<span class="lineNum">     927 </span>                :            : 
<span class="lineNum">     928 </span>                :            : // ParseTime()
<span class="lineNum">     929 </span>                :            : //
<span class="lineNum">     930 </span>                :            : // Parses an input std::string according to the provided format std::string and
<span class="lineNum">     931 </span>                :            : // returns the corresponding `absl::Time`. Uses strftime()-like formatting
<span class="lineNum">     932 </span>                :            : // options, with the same extensions as FormatTime(), but with the
<span class="lineNum">     933 </span>                :            : // exceptions that %E#S is interpreted as %E*S, and %E#f as %E*f.  %Ez
<span class="lineNum">     934 </span>                :            : // and %E*z also accept the same inputs.
<span class="lineNum">     935 </span>                :            : //
<span class="lineNum">     936 </span>                :            : // %Y consumes as many numeric characters as it can, so the matching data
<span class="lineNum">     937 </span>                :            : // should always be terminated with a non-numeric.  %E4Y always consumes
<span class="lineNum">     938 </span>                :            : // exactly four characters, including any sign.
<span class="lineNum">     939 </span>                :            : //
<span class="lineNum">     940 </span>                :            : // Unspecified fields are taken from the default date and time of ...
<span class="lineNum">     941 </span>                :            : //
<span class="lineNum">     942 </span>                :            : //   &quot;1970-01-01 00:00:00.0 +0000&quot;
<span class="lineNum">     943 </span>                :            : //
<span class="lineNum">     944 </span>                :            : // For example, parsing a std::string of &quot;15:45&quot; (%H:%M) will return an absl::Time
<span class="lineNum">     945 </span>                :            : // that represents &quot;1970-01-01 15:45:00.0 +0000&quot;.
<span class="lineNum">     946 </span>                :            : //
<span class="lineNum">     947 </span>                :            : // Note that since ParseTime() returns time instants, it makes the most sense
<span class="lineNum">     948 </span>                :            : // to parse fully-specified date/time strings that include a UTC offset (%z,
<span class="lineNum">     949 </span>                :            : // %Ez, or %E*z).
<span class="lineNum">     950 </span>                :            : //
<span class="lineNum">     951 </span>                :            : // Note also that `absl::ParseTime()` only heeds the fields year, month, day,
<span class="lineNum">     952 </span>                :            : // hour, minute, (fractional) second, and UTC offset.  Other fields, like
<span class="lineNum">     953 </span>                :            : // weekday (%a or %A), while parsed for syntactic validity, are ignored
<span class="lineNum">     954 </span>                :            : // in the conversion.
<span class="lineNum">     955 </span>                :            : //
<span class="lineNum">     956 </span>                :            : // Date and time fields that are out-of-range will be treated as errors
<span class="lineNum">     957 </span>                :            : // rather than normalizing them like `absl::FromDateTime()` does.  For example,
<span class="lineNum">     958 </span>                :            : // it is an error to parse the date &quot;Oct 32, 2013&quot; because 32 is out of range.
<span class="lineNum">     959 </span>                :            : //
<span class="lineNum">     960 </span>                :            : // A leap second of &quot;:60&quot; is normalized to &quot;:00&quot; of the following minute
<span class="lineNum">     961 </span>                :            : // with fractional seconds discarded.  The following table shows how the
<span class="lineNum">     962 </span>                :            : // given seconds and subseconds will be parsed:
<span class="lineNum">     963 </span>                :            : //
<span class="lineNum">     964 </span>                :            : //   &quot;59.x&quot; -&gt; 59.x  // exact
<span class="lineNum">     965 </span>                :            : //   &quot;60.x&quot; -&gt; 00.0  // normalized
<span class="lineNum">     966 </span>                :            : //   &quot;00.x&quot; -&gt; 00.x  // exact
<span class="lineNum">     967 </span>                :            : //
<span class="lineNum">     968 </span>                :            : // Errors are indicated by returning false and assigning an error message
<span class="lineNum">     969 </span>                :            : // to the &quot;err&quot; out param if it is non-null.
<span class="lineNum">     970 </span>                :            : //
<span class="lineNum">     971 </span>                :            : // Note: If the input std::string is exactly &quot;infinite-future&quot;, the returned
<span class="lineNum">     972 </span>                :            : // `absl::Time` will be `absl::InfiniteFuture()` and `true` will be returned.
<span class="lineNum">     973 </span>                :            : // If the input std::string is &quot;infinite-past&quot;, the returned `absl::Time` will be
<span class="lineNum">     974 </span>                :            : // `absl::InfinitePast()` and `true` will be returned.
<span class="lineNum">     975 </span>                :            : //
<span class="lineNum">     976 </span>                :            : bool ParseTime(const std::string&amp; format, const std::string&amp; input, Time* time,
<span class="lineNum">     977 </span>                :            :                std::string* err);
<span class="lineNum">     978 </span>                :            : 
<span class="lineNum">     979 </span>                :            : // Like ParseTime() above, but if the format std::string does not contain a UTC
<span class="lineNum">     980 </span>                :            : // offset specification (%z/%Ez/%E*z) then the input is interpreted in the
<span class="lineNum">     981 </span>                :            : // given TimeZone.  This means that the input, by itself, does not identify a
<span class="lineNum">     982 </span>                :            : // unique instant.  Being time-zone dependent, it also admits the possibility
<span class="lineNum">     983 </span>                :            : // of ambiguity or non-existence, in which case the &quot;pre&quot; time (as defined
<span class="lineNum">     984 </span>                :            : // for ConvertDateTime()) is returned.  For these reasons we recommend that
<span class="lineNum">     985 </span>                :            : // all date/time strings include a UTC offset so they're context independent.
<span class="lineNum">     986 </span>                :            : bool ParseTime(const std::string&amp; format, const std::string&amp; input, TimeZone tz,
<span class="lineNum">     987 </span>                :            :                Time* time, std::string* err);
<span class="lineNum">     988 </span>                :            : 
<span class="lineNum">     989 </span>                :            : // TODO(absl-team): Remove once dependencies are removed.
<span class="lineNum">     990 </span>                :            : 
<span class="lineNum">     991 </span>                :            : // ParseFlag()
<span class="lineNum">     992 </span>                :            : // UnparseFlag()
<span class="lineNum">     993 </span>                :            : //
<span class="lineNum">     994 </span>                :            : // Support for flag values of type Time. Time flags must be specified in a
<span class="lineNum">     995 </span>                :            : // format that matches absl::RFC3339_full. For example:
<span class="lineNum">     996 </span>                :            : //
<span class="lineNum">     997 </span>                :            : //   --start_time=2016-01-02T03:04:05.678+08:00
<span class="lineNum">     998 </span>                :            : //
<span class="lineNum">     999 </span>                :            : // Note: A UTC offset (or 'Z' indicating a zero-offset from UTC) is required.
<span class="lineNum">    1000 </span>                :            : //
<span class="lineNum">    1001 </span>                :            : // Additionally, if you'd like to specify a time as a count of
<span class="lineNum">    1002 </span>                :            : // seconds/milliseconds/etc from the Unix epoch, use an absl::Duration flag
<span class="lineNum">    1003 </span>                :            : // and add that duration to absl::UnixEpoch() to get an absl::Time.
<span class="lineNum">    1004 </span>                :            : bool ParseFlag(const std::string&amp; text, Time* t, std::string* error);
<span class="lineNum">    1005 </span>                :            : std::string UnparseFlag(Time t);
<span class="lineNum">    1006 </span>                :            : 
<span class="lineNum">    1007 </span>                :            : // TimeZone
<span class="lineNum">    1008 </span>                :            : //
<span class="lineNum">    1009 </span>                :            : // The `absl::TimeZone` is an opaque, small, value-type class representing a
<span class="lineNum">    1010 </span>                :            : // geo-political region within which particular rules are used for converting
<span class="lineNum">    1011 </span>                :            : // between absolute and civil times (see https://git.io/v59Ly). `absl::TimeZone`
<span class="lineNum">    1012 </span>                :            : // values are named using the TZ identifiers from the IANA Time Zone Database,
<span class="lineNum">    1013 </span>                :            : // such as &quot;America/Los_Angeles&quot; or &quot;Australia/Sydney&quot;. `absl::TimeZone` values
<span class="lineNum">    1014 </span>                :            : // are created from factory functions such as `absl::LoadTimeZone()`. Note:
<span class="lineNum">    1015 </span>                :            : // strings like &quot;PST&quot; and &quot;EDT&quot; are not valid TZ identifiers. Prefer to pass by
<span class="lineNum">    1016 </span>                :            : // value rather than const reference.
<span class="lineNum">    1017 </span>                :            : //
<span class="lineNum">    1018 </span>                :            : // For more on the fundamental concepts of time zones, absolute times, and civil
<span class="lineNum">    1019 </span>                :            : // times, see https://github.com/google/cctz#fundamental-concepts
<span class="lineNum">    1020 </span>                :            : //
<span class="lineNum">    1021 </span>                :            : // Examples:
<span class="lineNum">    1022 </span>                :            : //
<span class="lineNum">    1023 </span>                :            : //   absl::TimeZone utc = absl::UTCTimeZone();
<span class="lineNum">    1024 </span>                :            : //   absl::TimeZone pst = absl::FixedTimeZone(-8 * 60 * 60);
<span class="lineNum">    1025 </span>                :            : //   absl::TimeZone loc = absl::LocalTimeZone();
<span class="lineNum">    1026 </span>                :            : //   absl::TimeZone lax;
<span class="lineNum">    1027 </span>                :            : //   if (!absl::LoadTimeZone(&quot;America/Los_Angeles&quot;, &amp;lax)) { ... }
<span class="lineNum">    1028 </span>                :            : //
<span class="lineNum">    1029 </span>                :            : // See also:
<span class="lineNum">    1030 </span>                :            : // - https://github.com/google/cctz
<span class="lineNum">    1031 </span>                :            : // - http://www.iana.org/time-zones
<span class="lineNum">    1032 </span>                :            : // - http://en.wikipedia.org/wiki/Zoneinfo
<span class="lineNum">    1033 </span>                :            : class TimeZone {
<span class="lineNum">    1034 </span>                :            :  public:
<span class="lineNum">    1035 </span>                :            :   explicit TimeZone(time_internal::cctz::time_zone tz) : cz_(tz) {}
<span class="lineNum">    1036 </span>                :            :   TimeZone() = default;  // UTC, but prefer UTCTimeZone() to be explicit.
<span class="lineNum">    1037 </span>                :            :   TimeZone(const TimeZone&amp;) = default;
<span class="lineNum">    1038 </span>                :            :   TimeZone&amp; operator=(const TimeZone&amp;) = default;
<span class="lineNum">    1039 </span>                :            : 
<span class="lineNum">    1040 </span>                :            :   explicit operator time_internal::cctz::time_zone() const { return cz_; }
<span class="lineNum">    1041 </span>                :            : 
<span class="lineNum">    1042 </span>                :            :   std::string name() const { return cz_.name(); }
<span class="lineNum">    1043 </span>                :            : 
<span class="lineNum">    1044 </span>                :            :  private:
<span class="lineNum">    1045 </span>                :            :   friend bool operator==(TimeZone a, TimeZone b) { return a.cz_ == b.cz_; }
<span class="lineNum">    1046 </span>                :            :   friend bool operator!=(TimeZone a, TimeZone b) { return a.cz_ != b.cz_; }
<span class="lineNum">    1047 </span>                :            :   friend std::ostream&amp; operator&lt;&lt;(std::ostream&amp; os, TimeZone tz) {
<span class="lineNum">    1048 </span>                :            :     return os &lt;&lt; tz.name();
<span class="lineNum">    1049 </span>                :            :   }
<span class="lineNum">    1050 </span>                :            : 
<span class="lineNum">    1051 </span>                :            :   time_internal::cctz::time_zone cz_;
<span class="lineNum">    1052 </span>                :            : };
<span class="lineNum">    1053 </span>                :            : 
<span class="lineNum">    1054 </span>                :            : // LoadTimeZone()
<span class="lineNum">    1055 </span>                :            : //
<span class="lineNum">    1056 </span>                :            : // Loads the named zone. May perform I/O on the initial load of the named
<span class="lineNum">    1057 </span>                :            : // zone. If the name is invalid, or some other kind of error occurs, returns
<span class="lineNum">    1058 </span>                :            : // `false` and `*tz` is set to the UTC time zone.
<span class="lineNum">    1059 </span>                :            : inline bool LoadTimeZone(const std::string&amp; name, TimeZone* tz) {
<span class="lineNum">    1060 </span>                :            :   if (name == &quot;localtime&quot;) {
<span class="lineNum">    1061 </span>                :            :     *tz = TimeZone(time_internal::cctz::local_time_zone());
<span class="lineNum">    1062 </span>                :            :     return true;
<span class="lineNum">    1063 </span>                :            :   }
<span class="lineNum">    1064 </span>                :            :   time_internal::cctz::time_zone cz;
<span class="lineNum">    1065 </span>                :            :   const bool b = time_internal::cctz::load_time_zone(name, &amp;cz);
<span class="lineNum">    1066 </span>                :            :   *tz = TimeZone(cz);
<span class="lineNum">    1067 </span>                :            :   return b;
<span class="lineNum">    1068 </span>                :            : }
<span class="lineNum">    1069 </span>                :            : 
<span class="lineNum">    1070 </span>                :            : // FixedTimeZone()
<span class="lineNum">    1071 </span>                :            : //
<span class="lineNum">    1072 </span>                :            : // Returns a TimeZone that is a fixed offset (seconds east) from UTC.
<span class="lineNum">    1073 </span>                :            : // Note: If the absolute value of the offset is greater than 24 hours
<span class="lineNum">    1074 </span>                :            : // you'll get UTC (i.e., no offset) instead.
<span class="lineNum">    1075 </span>                :            : inline TimeZone FixedTimeZone(int seconds) {
<span class="lineNum">    1076 </span>                :            :   return TimeZone(
<span class="lineNum">    1077 </span>                :            :       time_internal::cctz::fixed_time_zone(std::chrono::seconds(seconds)));
<span class="lineNum">    1078 </span>                :            : }
<span class="lineNum">    1079 </span>                :            : 
<span class="lineNum">    1080 </span>                :            : // UTCTimeZone()
<span class="lineNum">    1081 </span>                :            : //
<span class="lineNum">    1082 </span>                :            : // Convenience method returning the UTC time zone.
<span class="lineNum">    1083 </span>                :            : inline TimeZone UTCTimeZone() {
<span class="lineNum">    1084 </span>                :            :   return TimeZone(time_internal::cctz::utc_time_zone());
<span class="lineNum">    1085 </span>                :            : }
<span class="lineNum">    1086 </span>                :            : 
<span class="lineNum">    1087 </span>                :            : // LocalTimeZone()
<span class="lineNum">    1088 </span>                :            : //
<span class="lineNum">    1089 </span>                :            : // Convenience method returning the local time zone, or UTC if there is
<span class="lineNum">    1090 </span>                :            : // no configured local zone.  Warning: Be wary of using LocalTimeZone(),
<span class="lineNum">    1091 </span>                :            : // and particularly so in a server process, as the zone configured for the
<span class="lineNum">    1092 </span>                :            : // local machine should be irrelevant.  Prefer an explicit zone name.
<span class="lineNum">    1093 </span>                :            : inline TimeZone LocalTimeZone() {
<span class="lineNum">    1094 </span>                :            :   return TimeZone(time_internal::cctz::local_time_zone());
<span class="lineNum">    1095 </span>                :            : }
<span class="lineNum">    1096 </span>                :            : 
<span class="lineNum">    1097 </span>                :            : // ============================================================================
<span class="lineNum">    1098 </span>                :            : // Implementation Details Follow
<span class="lineNum">    1099 </span>                :            : // ============================================================================
<span class="lineNum">    1100 </span>                :            : 
<span class="lineNum">    1101 </span>                :            : namespace time_internal {
<span class="lineNum">    1102 </span>                :            : 
<span class="lineNum">    1103 </span>                :            : // Creates a Duration with a given representation.
<a name="1104"><span class="lineNum">    1104 </span>                :            : // REQUIRES: hi,lo is a valid representation of a Duration as specified</a>
<span class="lineNum">    1105 </span>                :            : // in time/duration.cc.
<span class="lineNum">    1106 </span>                :<span class="lineCov">         35 : constexpr Duration MakeDuration(int64_t hi, uint32_t lo = 0) {</span>
<span class="lineNum">    1107 </span>                :<span class="lineCov">         35 :   return Duration(hi, lo);</span>
<a name="1108"><span class="lineNum">    1108 </span>                :            : }</a>
<span class="lineNum">    1109 </span>                :            : 
<span class="lineNum">    1110 </span>                :<span class="lineCov">         35 : constexpr Duration MakeDuration(int64_t hi, int64_t lo) {</span>
<span class="lineNum">    1111 </span>                :<span class="lineCov">         35 :   return MakeDuration(hi, static_cast&lt;uint32_t&gt;(lo));</span>
<span class="lineNum">    1112 </span>                :            : }
<span class="lineNum">    1113 </span>                :            : 
<span class="lineNum">    1114 </span>                :            : // Creates a normalized Duration from an almost-normalized (sec,ticks)
<span class="lineNum">    1115 </span>                :            : // pair. sec may be positive or negative.  ticks must be in the range
<a name="1116"><span class="lineNum">    1116 </span>                :            : // -kTicksPerSecond &lt; *ticks &lt; kTicksPerSecond.  If ticks is negative it</a>
<span class="lineNum">    1117 </span>                :            : // will be normalized to a positive value in the resulting Duration.
<span class="lineNum">    1118 </span>                :<span class="lineCov">          5 : constexpr Duration MakeNormalizedDuration(int64_t sec, int64_t ticks) {</span>
<span class="lineNum">    1119 </span>                :<span class="lineNoCov">          0 :   return (ticks &lt; 0) ? MakeDuration(sec - 1, ticks + kTicksPerSecond)</span>
<span class="lineNum">    1120 </span>[<span class="branchNoCov" title="Branch 0 was not taken"> - </span><span class="branchCov" title="Branch 1 was taken 5 times"> + </span>][<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineCov">          5 :                      : MakeDuration(sec, ticks);</span>
<a name="1121"><span class="lineNum">    1121 </span>                :            : }</a>
<a name="1122"><span class="lineNum">    1122 </span>                :            : // Provide access to the Duration representation.</a>
<span class="lineNum">    1123 </span>                :<span class="lineCov">         30 : constexpr int64_t GetRepHi(Duration d) { return d.rep_hi_; }</span>
<span class="lineNum">    1124 </span>                :<span class="lineCov">         10 : constexpr uint32_t GetRepLo(Duration d) { return d.rep_lo_; }</span>
<span class="lineNum">    1125 </span>                :            : constexpr bool IsInfiniteDuration(Duration d) { return GetRepLo(d) == ~0U; }
<span class="lineNum">    1126 </span>                :            : 
<span class="lineNum">    1127 </span>                :            : // Returns an infinite Duration with the opposite sign.
<span class="lineNum">    1128 </span>                :            : // REQUIRES: IsInfiniteDuration(d)
<span class="lineNum">    1129 </span>                :            : constexpr Duration OppositeInfinity(Duration d) {
<span class="lineNum">    1130 </span>                :            :   return GetRepHi(d) &lt; 0
<span class="lineNum">    1131 </span>                :            :              ? MakeDuration(std::numeric_limits&lt;int64_t&gt;::max(), ~0U)
<span class="lineNum">    1132 </span>                :            :              : MakeDuration(std::numeric_limits&lt;int64_t&gt;::min(), ~0U);
<span class="lineNum">    1133 </span>                :            : }
<span class="lineNum">    1134 </span>                :            : 
<span class="lineNum">    1135 </span>                :            : // Returns (-n)-1 (equivalently -(n+1)) without avoidable overflow.
<span class="lineNum">    1136 </span>                :            : constexpr int64_t NegateAndSubtractOne(int64_t n) {
<span class="lineNum">    1137 </span>                :            :   // Note: Good compilers will optimize this expression to ~n when using
<span class="lineNum">    1138 </span>                :            :   // a two's-complement representation (which is required for int64_t).
<span class="lineNum">    1139 </span>                :            :   return (n &lt; 0) ? -(n + 1) : (-n) - 1;
<span class="lineNum">    1140 </span>                :            : }
<span class="lineNum">    1141 </span>                :            : 
<span class="lineNum">    1142 </span>                :            : // Map between a Time and a Duration since the Unix epoch.  Note that these
<span class="lineNum">    1143 </span>                :            : // functions depend on the above mentioned choice of the Unix epoch for the
<a name="1144"><span class="lineNum">    1144 </span>                :            : // Time representation (and both need to be Time friends).  Without this</a>
<span class="lineNum">    1145 </span>                :            : // knowledge, we would need to add-in/subtract-out UnixEpoch() respectively.
<span class="lineNum">    1146 </span>                :<span class="lineCov">         70 : constexpr Time FromUnixDuration(Duration d) { return Time(d); }</span>
<span class="lineNum">    1147 </span>                :            : constexpr Duration ToUnixDuration(Time t) { return t.rep_; }
<span class="lineNum">    1148 </span>                :            : 
<span class="lineNum">    1149 </span>                :            : template &lt;std::intmax_t N&gt;
<span class="lineNum">    1150 </span>                :            : constexpr Duration FromInt64(int64_t v, std::ratio&lt;1, N&gt;) {
<span class="lineNum">    1151 </span>                :            :   static_assert(0 &lt; N &amp;&amp; N &lt;= 1000 * 1000 * 1000, &quot;Unsupported ratio&quot;);
<span class="lineNum">    1152 </span>                :            :   // Subsecond ratios cannot overflow.
<span class="lineNum">    1153 </span>                :            :   return MakeNormalizedDuration(
<span class="lineNum">    1154 </span>                :            :       v / N, v % N * kTicksPerNanosecond * 1000 * 1000 * 1000 / N);
<span class="lineNum">    1155 </span>                :            : }
<span class="lineNum">    1156 </span>                :            : constexpr Duration FromInt64(int64_t v, std::ratio&lt;60&gt;) {
<span class="lineNum">    1157 </span>                :            :   return Minutes(v);
<span class="lineNum">    1158 </span>                :            : }
<span class="lineNum">    1159 </span>                :            : constexpr Duration FromInt64(int64_t v, std::ratio&lt;3600&gt;) {
<span class="lineNum">    1160 </span>                :            :   return Hours(v);
<span class="lineNum">    1161 </span>                :            : }
<span class="lineNum">    1162 </span>                :            : 
<span class="lineNum">    1163 </span>                :            : // IsValidRep64&lt;T&gt;(0) is true if the expression `int64_t{std::declval&lt;T&gt;()}` is
<span class="lineNum">    1164 </span>                :            : // valid. That is, if a T can be assigned to an int64_t without narrowing.
<span class="lineNum">    1165 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">    1166 </span>                :            : constexpr auto IsValidRep64(int)
<span class="lineNum">    1167 </span>                :            :     -&gt; decltype(int64_t{std::declval&lt;T&gt;()}, bool()) {
<span class="lineNum">    1168 </span>                :            :   return true;
<span class="lineNum">    1169 </span>                :            : }
<span class="lineNum">    1170 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">    1171 </span>                :            : constexpr auto IsValidRep64(char) -&gt; bool {
<span class="lineNum">    1172 </span>                :            :   return false;
<span class="lineNum">    1173 </span>                :            : }
<span class="lineNum">    1174 </span>                :            : 
<span class="lineNum">    1175 </span>                :            : // Converts a std::chrono::duration to an absl::Duration.
<span class="lineNum">    1176 </span>                :            : template &lt;typename Rep, typename Period&gt;
<span class="lineNum">    1177 </span>                :            : constexpr Duration FromChrono(const std::chrono::duration&lt;Rep, Period&gt;&amp; d) {
<span class="lineNum">    1178 </span>                :            :   static_assert(IsValidRep64&lt;Rep&gt;(0), &quot;duration::rep is invalid&quot;);
<span class="lineNum">    1179 </span>                :            :   return FromInt64(int64_t{d.count()}, Period{});
<span class="lineNum">    1180 </span>                :            : }
<span class="lineNum">    1181 </span>                :            : 
<span class="lineNum">    1182 </span>                :            : template &lt;typename Ratio&gt;
<span class="lineNum">    1183 </span>                :            : int64_t ToInt64(Duration d, Ratio) {
<span class="lineNum">    1184 </span>                :            :   // Note: This may be used on MSVC, which may have a system_clock period of
<span class="lineNum">    1185 </span>                :            :   // std::ratio&lt;1, 10 * 1000 * 1000&gt;
<span class="lineNum">    1186 </span>                :            :   return ToInt64Seconds(d * Ratio::den / Ratio::num);
<span class="lineNum">    1187 </span>                :            : }
<span class="lineNum">    1188 </span>                :            : // Fastpath implementations for the 6 common duration units.
<span class="lineNum">    1189 </span>                :            : inline int64_t ToInt64(Duration d, std::nano) {
<span class="lineNum">    1190 </span>                :            :   return ToInt64Nanoseconds(d);
<span class="lineNum">    1191 </span>                :            : }
<span class="lineNum">    1192 </span>                :            : inline int64_t ToInt64(Duration d, std::micro) {
<span class="lineNum">    1193 </span>                :            :   return ToInt64Microseconds(d);
<span class="lineNum">    1194 </span>                :            : }
<span class="lineNum">    1195 </span>                :            : inline int64_t ToInt64(Duration d, std::milli) {
<span class="lineNum">    1196 </span>                :            :   return ToInt64Milliseconds(d);
<span class="lineNum">    1197 </span>                :            : }
<span class="lineNum">    1198 </span>                :            : inline int64_t ToInt64(Duration d, std::ratio&lt;1&gt;) {
<span class="lineNum">    1199 </span>                :            :   return ToInt64Seconds(d);
<span class="lineNum">    1200 </span>                :            : }
<span class="lineNum">    1201 </span>                :            : inline int64_t ToInt64(Duration d, std::ratio&lt;60&gt;) {
<span class="lineNum">    1202 </span>                :            :   return ToInt64Minutes(d);
<span class="lineNum">    1203 </span>                :            : }
<span class="lineNum">    1204 </span>                :            : inline int64_t ToInt64(Duration d, std::ratio&lt;3600&gt;) {
<span class="lineNum">    1205 </span>                :            :   return ToInt64Hours(d);
<span class="lineNum">    1206 </span>                :            : }
<span class="lineNum">    1207 </span>                :            : 
<span class="lineNum">    1208 </span>                :            : // Converts an absl::Duration to a chrono duration of type T.
<span class="lineNum">    1209 </span>                :            : template &lt;typename T&gt;
<span class="lineNum">    1210 </span>                :            : T ToChronoDuration(Duration d) {
<span class="lineNum">    1211 </span>                :            :   using Rep = typename T::rep;
<span class="lineNum">    1212 </span>                :            :   using Period = typename T::period;
<span class="lineNum">    1213 </span>                :            :   static_assert(IsValidRep64&lt;Rep&gt;(0), &quot;duration::rep is invalid&quot;);
<span class="lineNum">    1214 </span>                :            :   if (time_internal::IsInfiniteDuration(d))
<span class="lineNum">    1215 </span>                :            :     return d &lt; ZeroDuration() ? T::min() : T::max();
<span class="lineNum">    1216 </span>                :            :   const auto v = ToInt64(d, Period{});
<span class="lineNum">    1217 </span>                :            :   if (v &gt; std::numeric_limits&lt;Rep&gt;::max()) return T::max();
<span class="lineNum">    1218 </span>                :            :   if (v &lt; std::numeric_limits&lt;Rep&gt;::min()) return T::min();
<span class="lineNum">    1219 </span>                :            :   return T{v};
<span class="lineNum">    1220 </span>                :            : }
<span class="lineNum">    1221 </span>                :            : 
<a name="1222"><span class="lineNum">    1222 </span>                :            : }  // namespace time_internal</a>
<span class="lineNum">    1223 </span>                :            : 
<span class="lineNum">    1224 </span>                :<span class="lineNoCov">          0 : constexpr bool operator&lt;(Duration lhs, Duration rhs) {</span>
<span class="lineNum">    1225 </span>                :<span class="lineNoCov">          0 :   return time_internal::GetRepHi(lhs) != time_internal::GetRepHi(rhs)</span>
<span class="lineNum">    1226 </span>                :<span class="lineNoCov">          0 :              ? time_internal::GetRepHi(lhs) &lt; time_internal::GetRepHi(rhs)</span>
<span class="lineNum">    1227 </span>                :<span class="lineNoCov">          0 :              : time_internal::GetRepHi(lhs) == std::numeric_limits&lt;int64_t&gt;::min()</span>
<span class="lineNum">    1228 </span>                :<span class="lineNoCov">          0 :                    ? time_internal::GetRepLo(lhs) + 1 &lt;</span>
<span class="lineNum">    1229 </span>                :<span class="lineNoCov">          0 :                          time_internal::GetRepLo(rhs) + 1</span>
<span class="lineNum">    1230 </span>                :<span class="lineNoCov">          0 :                    : time_internal::GetRepLo(lhs) &lt;</span>
<span class="lineNum">    1231 </span>  [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span><span class="branchNoExec" title="Branch 2 was not executed"> # </span><span class="branchNoExec" title="Branch 3 was not executed"> # </span>]:<span class="lineNoCov">          0 :                          time_internal::GetRepLo(rhs);</span>
<span class="lineNum">    1232 </span>                :            : }
<span class="lineNum">    1233 </span>                :            : 
<span class="lineNum">    1234 </span>                :            : constexpr bool operator==(Duration lhs, Duration rhs) {
<span class="lineNum">    1235 </span>                :            :   return time_internal::GetRepHi(lhs) == time_internal::GetRepHi(rhs) &amp;&amp;
<span class="lineNum">    1236 </span>                :            :          time_internal::GetRepLo(lhs) == time_internal::GetRepLo(rhs);
<span class="lineNum">    1237 </span>                :            : }
<span class="lineNum">    1238 </span>                :            : 
<span class="lineNum">    1239 </span>                :            : constexpr Duration operator-(Duration d) {
<span class="lineNum">    1240 </span>                :            :   // This is a little interesting because of the special cases.
<span class="lineNum">    1241 </span>                :            :   //
<span class="lineNum">    1242 </span>                :            :   // If rep_lo_ is zero, we have it easy; it's safe to negate rep_hi_, we're
<span class="lineNum">    1243 </span>                :            :   // dealing with an integral number of seconds, and the only special case is
<span class="lineNum">    1244 </span>                :            :   // the maximum negative finite duration, which can't be negated.
<span class="lineNum">    1245 </span>                :            :   //
<span class="lineNum">    1246 </span>                :            :   // Infinities stay infinite, and just change direction.
<span class="lineNum">    1247 </span>                :            :   //
<span class="lineNum">    1248 </span>                :            :   // Finally we're in the case where rep_lo_ is non-zero, and we can borrow
<span class="lineNum">    1249 </span>                :            :   // a second's worth of ticks and avoid overflow (as negating int64_t-min + 1
<span class="lineNum">    1250 </span>                :            :   // is safe).
<span class="lineNum">    1251 </span>                :            :   return time_internal::GetRepLo(d) == 0
<span class="lineNum">    1252 </span>                :            :              ? time_internal::GetRepHi(d) == std::numeric_limits&lt;int64_t&gt;::min()
<span class="lineNum">    1253 </span>                :            :                    ? InfiniteDuration()
<span class="lineNum">    1254 </span>                :            :                    : time_internal::MakeDuration(-time_internal::GetRepHi(d))
<span class="lineNum">    1255 </span>                :            :              : time_internal::IsInfiniteDuration(d)
<span class="lineNum">    1256 </span>                :            :                    ? time_internal::OppositeInfinity(d)
<span class="lineNum">    1257 </span>                :            :                    : time_internal::MakeDuration(
<span class="lineNum">    1258 </span>                :            :                          time_internal::NegateAndSubtractOne(
<span class="lineNum">    1259 </span>                :            :                              time_internal::GetRepHi(d)),
<span class="lineNum">    1260 </span>                :            :                          time_internal::kTicksPerSecond -
<span class="lineNum">    1261 </span>                :            :                              time_internal::GetRepLo(d));
<a name="1262"><span class="lineNum">    1262 </span>                :            : }</a>
<span class="lineNum">    1263 </span>                :            : 
<span class="lineNum">    1264 </span>                :<span class="lineCov">          5 : constexpr Duration Nanoseconds(int64_t n) {</span>
<span class="lineNum">    1265 </span>                :            :   return time_internal::MakeNormalizedDuration(
<span class="lineNum">    1266 </span>                :            :       n / (1000 * 1000 * 1000),
<span class="lineNum">    1267 </span>                :<span class="lineCov">          5 :       n % (1000 * 1000 * 1000) * time_internal::kTicksPerNanosecond);</span>
<span class="lineNum">    1268 </span>                :            : }
<span class="lineNum">    1269 </span>                :            : 
<span class="lineNum">    1270 </span>                :            : constexpr Duration Microseconds(int64_t n) {
<span class="lineNum">    1271 </span>                :            :   return time_internal::MakeNormalizedDuration(
<span class="lineNum">    1272 </span>                :            :       n / (1000 * 1000),
<span class="lineNum">    1273 </span>                :            :       n % (1000 * 1000) * (1000 * time_internal::kTicksPerNanosecond));
<span class="lineNum">    1274 </span>                :            : }
<span class="lineNum">    1275 </span>                :            : 
<span class="lineNum">    1276 </span>                :            : constexpr Duration Milliseconds(int64_t n) {
<span class="lineNum">    1277 </span>                :            :   return time_internal::MakeNormalizedDuration(
<span class="lineNum">    1278 </span>                :            :       n / 1000, n % 1000 * (1000 * 1000 * time_internal::kTicksPerNanosecond));
<span class="lineNum">    1279 </span>                :            : }
<span class="lineNum">    1280 </span>                :            : 
<span class="lineNum">    1281 </span>                :            : constexpr Duration Seconds(int64_t n) { return time_internal::MakeDuration(n); }
<span class="lineNum">    1282 </span>                :            : 
<span class="lineNum">    1283 </span>                :            : constexpr Duration Minutes(int64_t n) {
<span class="lineNum">    1284 </span>                :            :   return (n &lt;= std::numeric_limits&lt;int64_t&gt;::max() / 60 &amp;&amp;
<span class="lineNum">    1285 </span>                :            :           n &gt;= std::numeric_limits&lt;int64_t&gt;::min() / 60)
<span class="lineNum">    1286 </span>                :            :              ? time_internal::MakeDuration(n * 60)
<span class="lineNum">    1287 </span>                :            :              : n &gt; 0 ? InfiniteDuration() : -InfiniteDuration();
<span class="lineNum">    1288 </span>                :            : }
<span class="lineNum">    1289 </span>                :            : 
<span class="lineNum">    1290 </span>                :            : constexpr Duration Hours(int64_t n) {
<span class="lineNum">    1291 </span>                :            :   return (n &lt;= std::numeric_limits&lt;int64_t&gt;::max() / 3600 &amp;&amp;
<span class="lineNum">    1292 </span>                :            :           n &gt;= std::numeric_limits&lt;int64_t&gt;::min() / 3600)
<span class="lineNum">    1293 </span>                :            :              ? time_internal::MakeDuration(n * 3600)
<span class="lineNum">    1294 </span>                :            :              : n &gt; 0 ? InfiniteDuration() : -InfiniteDuration();
<span class="lineNum">    1295 </span>                :            : }
<span class="lineNum">    1296 </span>                :            : 
<span class="lineNum">    1297 </span>                :            : constexpr Duration InfiniteDuration() {
<span class="lineNum">    1298 </span>                :            :   return time_internal::MakeDuration(std::numeric_limits&lt;int64_t&gt;::max(), ~0U);
<span class="lineNum">    1299 </span>                :            : }
<span class="lineNum">    1300 </span>                :            : 
<span class="lineNum">    1301 </span>                :            : constexpr Duration FromChrono(const std::chrono::nanoseconds&amp; d) {
<span class="lineNum">    1302 </span>                :            :   return time_internal::FromChrono(d);
<span class="lineNum">    1303 </span>                :            : }
<span class="lineNum">    1304 </span>                :            : constexpr Duration FromChrono(const std::chrono::microseconds&amp; d) {
<span class="lineNum">    1305 </span>                :            :   return time_internal::FromChrono(d);
<span class="lineNum">    1306 </span>                :            : }
<span class="lineNum">    1307 </span>                :            : constexpr Duration FromChrono(const std::chrono::milliseconds&amp; d) {
<span class="lineNum">    1308 </span>                :            :   return time_internal::FromChrono(d);
<span class="lineNum">    1309 </span>                :            : }
<span class="lineNum">    1310 </span>                :            : constexpr Duration FromChrono(const std::chrono::seconds&amp; d) {
<span class="lineNum">    1311 </span>                :            :   return time_internal::FromChrono(d);
<span class="lineNum">    1312 </span>                :            : }
<span class="lineNum">    1313 </span>                :            : constexpr Duration FromChrono(const std::chrono::minutes&amp; d) {
<span class="lineNum">    1314 </span>                :            :   return time_internal::FromChrono(d);
<span class="lineNum">    1315 </span>                :            : }
<span class="lineNum">    1316 </span>                :            : constexpr Duration FromChrono(const std::chrono::hours&amp; d) {
<span class="lineNum">    1317 </span>                :            :   return time_internal::FromChrono(d);
<a name="1318"><span class="lineNum">    1318 </span>                :            : }</a>
<span class="lineNum">    1319 </span>                :            : 
<span class="lineNum">    1320 </span>                :<span class="lineCov">          5 : constexpr Time FromUnixNanos(int64_t ns) {</span>
<span class="lineNum">    1321 </span>                :<span class="lineCov">          5 :   return time_internal::FromUnixDuration(Nanoseconds(ns));</span>
<span class="lineNum">    1322 </span>                :            : }
<span class="lineNum">    1323 </span>                :            : 
<span class="lineNum">    1324 </span>                :            : constexpr Time FromUnixMicros(int64_t us) {
<span class="lineNum">    1325 </span>                :            :   return time_internal::FromUnixDuration(Microseconds(us));
<span class="lineNum">    1326 </span>                :            : }
<span class="lineNum">    1327 </span>                :            : 
<span class="lineNum">    1328 </span>                :            : constexpr Time FromUnixMillis(int64_t ms) {
<span class="lineNum">    1329 </span>                :            :   return time_internal::FromUnixDuration(Milliseconds(ms));
<span class="lineNum">    1330 </span>                :            : }
<span class="lineNum">    1331 </span>                :            : 
<span class="lineNum">    1332 </span>                :            : constexpr Time FromUnixSeconds(int64_t s) {
<span class="lineNum">    1333 </span>                :            :   return time_internal::FromUnixDuration(Seconds(s));
<span class="lineNum">    1334 </span>                :            : }
<span class="lineNum">    1335 </span>                :            : 
<span class="lineNum">    1336 </span>                :            : constexpr Time FromTimeT(time_t t) {
<span class="lineNum">    1337 </span>                :            :   return time_internal::FromUnixDuration(Seconds(t));
<span class="lineNum">    1338 </span>                :            : }
<span class="lineNum">    1339 </span>                :            : 
<span class="lineNum">    1340 </span>                :            : }  // namespace absl
<span class="lineNum">    1341 </span>                :            : 
<span class="lineNum">    1342 </span>                :            : #endif  // ABSL_TIME_TIME_H_
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>

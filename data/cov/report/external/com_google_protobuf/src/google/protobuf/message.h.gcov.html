<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">

<html lang="en">

<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <title>LCOV - stripped_conv.info - external/com_google_protobuf/src/google/protobuf/message.h</title>
  <link rel="stylesheet" type="text/css" href="../../../../../gcov.css">
</head>

<body>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="title">LCOV - code coverage report</td></tr>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>

    <tr>
      <td width="100%">
        <table cellpadding=1 border=0 width="100%">
          <tr>
            <td width="10%" class="headerItem">Current view:</td>
            <td width="35%" class="headerValue"><a href="../../../../../index.html">top level</a> - <a href="index.html">external/com_google_protobuf/src/google/protobuf</a> - message.h<span style="font-size: 80%;"> (source / <a href="message.h.func-sort-c.html">functions</a>)</span></td>
            <td width="5%"></td>
            <td width="15%"></td>
            <td width="10%" class="headerCovTableHead">Hit</td>
            <td width="10%" class="headerCovTableHead">Total</td>
            <td width="15%" class="headerCovTableHead">Coverage</td>
          </tr>
          <tr>
            <td class="headerItem">Test:</td>
            <td class="headerValue">stripped_conv.info</td>
            <td></td>
            <td class="headerItem">Lines:</td>
            <td class="headerCovTableEntry">5</td>
            <td class="headerCovTableEntry">12</td>
            <td class="headerCovTableEntryLo">41.7 %</td>
          </tr>
          <tr>
            <td class="headerItem">Date:</td>
            <td class="headerValue">2020-05-21 16:34:32</td>
            <td></td>
            <td class="headerItem">Functions:</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntry">7</td>
            <td class="headerCovTableEntryLo">57.1 %</td>
          </tr>
          <tr>
            <td></td>
            <td></td>
            <td></td>
            <td class="headerItem">Branches:</td>
            <td class="headerCovTableEntry">1</td>
            <td class="headerCovTableEntry">4</td>
            <td class="headerCovTableEntryLo">25.0 %</td>
          </tr>
          <tr><td><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
        </table>
      </td>
    </tr>

    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
  </table>

  <table cellpadding=0 cellspacing=0 border=0>
    <tr>
      <td><br></td>
    </tr>
    <tr>
      <td>
<pre class="sourceHeading">           Branch data     Line data    Source code</pre>
<pre class="source">
<a name="1"><span class="lineNum">       1 </span>                :            : // Protocol Buffers - Google's data interchange format</a>
<span class="lineNum">       2 </span>                :            : // Copyright 2008 Google Inc.  All rights reserved.
<span class="lineNum">       3 </span>                :            : // https://developers.google.com/protocol-buffers/
<span class="lineNum">       4 </span>                :            : //
<span class="lineNum">       5 </span>                :            : // Redistribution and use in source and binary forms, with or without
<span class="lineNum">       6 </span>                :            : // modification, are permitted provided that the following conditions are
<span class="lineNum">       7 </span>                :            : // met:
<span class="lineNum">       8 </span>                :            : //
<span class="lineNum">       9 </span>                :            : //     * Redistributions of source code must retain the above copyright
<span class="lineNum">      10 </span>                :            : // notice, this list of conditions and the following disclaimer.
<span class="lineNum">      11 </span>                :            : //     * Redistributions in binary form must reproduce the above
<span class="lineNum">      12 </span>                :            : // copyright notice, this list of conditions and the following disclaimer
<span class="lineNum">      13 </span>                :            : // in the documentation and/or other materials provided with the
<span class="lineNum">      14 </span>                :            : // distribution.
<span class="lineNum">      15 </span>                :            : //     * Neither the name of Google Inc. nor the names of its
<span class="lineNum">      16 </span>                :            : // contributors may be used to endorse or promote products derived from
<span class="lineNum">      17 </span>                :            : // this software without specific prior written permission.
<span class="lineNum">      18 </span>                :            : //
<span class="lineNum">      19 </span>                :            : // THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
<span class="lineNum">      20 </span>                :            : // &quot;AS IS&quot; AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
<span class="lineNum">      21 </span>                :            : // LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
<span class="lineNum">      22 </span>                :            : // A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
<span class="lineNum">      23 </span>                :            : // OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
<span class="lineNum">      24 </span>                :            : // SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
<span class="lineNum">      25 </span>                :            : // LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
<span class="lineNum">      26 </span>                :            : // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
<span class="lineNum">      27 </span>                :            : // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
<span class="lineNum">      28 </span>                :            : // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
<span class="lineNum">      29 </span>                :            : // OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
<span class="lineNum">      30 </span>                :            : 
<span class="lineNum">      31 </span>                :            : // Author: kenton@google.com (Kenton Varda)
<span class="lineNum">      32 </span>                :            : //  Based on original Protocol Buffers design by
<span class="lineNum">      33 </span>                :            : //  Sanjay Ghemawat, Jeff Dean, and others.
<span class="lineNum">      34 </span>                :            : //
<span class="lineNum">      35 </span>                :            : // Defines Message, the abstract interface implemented by non-lite
<span class="lineNum">      36 </span>                :            : // protocol message objects.  Although it's possible to implement this
<span class="lineNum">      37 </span>                :            : // interface manually, most users will use the protocol compiler to
<span class="lineNum">      38 </span>                :            : // generate implementations.
<span class="lineNum">      39 </span>                :            : //
<span class="lineNum">      40 </span>                :            : // Example usage:
<span class="lineNum">      41 </span>                :            : //
<span class="lineNum">      42 </span>                :            : // Say you have a message defined as:
<span class="lineNum">      43 </span>                :            : //
<span class="lineNum">      44 </span>                :            : //   message Foo {
<span class="lineNum">      45 </span>                :            : //     optional string text = 1;
<span class="lineNum">      46 </span>                :            : //     repeated int32 numbers = 2;
<span class="lineNum">      47 </span>                :            : //   }
<span class="lineNum">      48 </span>                :            : //
<span class="lineNum">      49 </span>                :            : // Then, if you used the protocol compiler to generate a class from the above
<span class="lineNum">      50 </span>                :            : // definition, you could use it like so:
<span class="lineNum">      51 </span>                :            : //
<span class="lineNum">      52 </span>                :            : //   string data;  // Will store a serialized version of the message.
<span class="lineNum">      53 </span>                :            : //
<span class="lineNum">      54 </span>                :            : //   {
<span class="lineNum">      55 </span>                :            : //     // Create a message and serialize it.
<span class="lineNum">      56 </span>                :            : //     Foo foo;
<span class="lineNum">      57 </span>                :            : //     foo.set_text(&quot;Hello World!&quot;);
<span class="lineNum">      58 </span>                :            : //     foo.add_numbers(1);
<span class="lineNum">      59 </span>                :            : //     foo.add_numbers(5);
<span class="lineNum">      60 </span>                :            : //     foo.add_numbers(42);
<span class="lineNum">      61 </span>                :            : //
<span class="lineNum">      62 </span>                :            : //     foo.SerializeToString(&amp;data);
<span class="lineNum">      63 </span>                :            : //   }
<span class="lineNum">      64 </span>                :            : //
<span class="lineNum">      65 </span>                :            : //   {
<span class="lineNum">      66 </span>                :            : //     // Parse the serialized message and check that it contains the
<span class="lineNum">      67 </span>                :            : //     // correct data.
<span class="lineNum">      68 </span>                :            : //     Foo foo;
<span class="lineNum">      69 </span>                :            : //     foo.ParseFromString(data);
<span class="lineNum">      70 </span>                :            : //
<span class="lineNum">      71 </span>                :            : //     assert(foo.text() == &quot;Hello World!&quot;);
<span class="lineNum">      72 </span>                :            : //     assert(foo.numbers_size() == 3);
<span class="lineNum">      73 </span>                :            : //     assert(foo.numbers(0) == 1);
<span class="lineNum">      74 </span>                :            : //     assert(foo.numbers(1) == 5);
<span class="lineNum">      75 </span>                :            : //     assert(foo.numbers(2) == 42);
<span class="lineNum">      76 </span>                :            : //   }
<span class="lineNum">      77 </span>                :            : //
<span class="lineNum">      78 </span>                :            : //   {
<span class="lineNum">      79 </span>                :            : //     // Same as the last block, but do it dynamically via the Message
<span class="lineNum">      80 </span>                :            : //     // reflection interface.
<span class="lineNum">      81 </span>                :            : //     Message* foo = new Foo;
<span class="lineNum">      82 </span>                :            : //     const Descriptor* descriptor = foo-&gt;GetDescriptor();
<span class="lineNum">      83 </span>                :            : //
<span class="lineNum">      84 </span>                :            : //     // Get the descriptors for the fields we're interested in and verify
<span class="lineNum">      85 </span>                :            : //     // their types.
<span class="lineNum">      86 </span>                :            : //     const FieldDescriptor* text_field = descriptor-&gt;FindFieldByName(&quot;text&quot;);
<span class="lineNum">      87 </span>                :            : //     assert(text_field != NULL);
<span class="lineNum">      88 </span>                :            : //     assert(text_field-&gt;type() == FieldDescriptor::TYPE_STRING);
<span class="lineNum">      89 </span>                :            : //     assert(text_field-&gt;label() == FieldDescriptor::LABEL_OPTIONAL);
<span class="lineNum">      90 </span>                :            : //     const FieldDescriptor* numbers_field = descriptor-&gt;
<span class="lineNum">      91 </span>                :            : //                                            FindFieldByName(&quot;numbers&quot;);
<span class="lineNum">      92 </span>                :            : //     assert(numbers_field != NULL);
<span class="lineNum">      93 </span>                :            : //     assert(numbers_field-&gt;type() == FieldDescriptor::TYPE_INT32);
<span class="lineNum">      94 </span>                :            : //     assert(numbers_field-&gt;label() == FieldDescriptor::LABEL_REPEATED);
<span class="lineNum">      95 </span>                :            : //
<span class="lineNum">      96 </span>                :            : //     // Parse the message.
<span class="lineNum">      97 </span>                :            : //     foo-&gt;ParseFromString(data);
<span class="lineNum">      98 </span>                :            : //
<span class="lineNum">      99 </span>                :            : //     // Use the reflection interface to examine the contents.
<span class="lineNum">     100 </span>                :            : //     const Reflection* reflection = foo-&gt;GetReflection();
<span class="lineNum">     101 </span>                :            : //     assert(reflection-&gt;GetString(*foo, text_field) == &quot;Hello World!&quot;);
<span class="lineNum">     102 </span>                :            : //     assert(reflection-&gt;FieldSize(*foo, numbers_field) == 3);
<span class="lineNum">     103 </span>                :            : //     assert(reflection-&gt;GetRepeatedInt32(*foo, numbers_field, 0) == 1);
<span class="lineNum">     104 </span>                :            : //     assert(reflection-&gt;GetRepeatedInt32(*foo, numbers_field, 1) == 5);
<span class="lineNum">     105 </span>                :            : //     assert(reflection-&gt;GetRepeatedInt32(*foo, numbers_field, 2) == 42);
<span class="lineNum">     106 </span>                :            : //
<span class="lineNum">     107 </span>                :            : //     delete foo;
<span class="lineNum">     108 </span>                :            : //   }
<span class="lineNum">     109 </span>                :            : 
<span class="lineNum">     110 </span>                :            : #ifndef GOOGLE_PROTOBUF_MESSAGE_H__
<span class="lineNum">     111 </span>                :            : #define GOOGLE_PROTOBUF_MESSAGE_H__
<span class="lineNum">     112 </span>                :            : 
<span class="lineNum">     113 </span>                :            : #include &lt;iosfwd&gt;
<span class="lineNum">     114 </span>                :            : #include &lt;string&gt;
<span class="lineNum">     115 </span>                :            : #include &lt;google/protobuf/stubs/type_traits.h&gt;
<span class="lineNum">     116 </span>                :            : #include &lt;vector&gt;
<span class="lineNum">     117 </span>                :            : 
<span class="lineNum">     118 </span>                :            : #include &lt;google/protobuf/arena.h&gt;
<span class="lineNum">     119 </span>                :            : #include &lt;google/protobuf/message_lite.h&gt;
<span class="lineNum">     120 </span>                :            : 
<span class="lineNum">     121 </span>                :            : #include &lt;google/protobuf/stubs/common.h&gt;
<span class="lineNum">     122 </span>                :            : #include &lt;google/protobuf/descriptor.h&gt;
<span class="lineNum">     123 </span>                :            : 
<span class="lineNum">     124 </span>                :            : 
<span class="lineNum">     125 </span>                :            : #define GOOGLE_PROTOBUF_HAS_ONEOF
<span class="lineNum">     126 </span>                :            : #define GOOGLE_PROTOBUF_HAS_ARENAS
<span class="lineNum">     127 </span>                :            : 
<span class="lineNum">     128 </span>                :            : namespace google {
<span class="lineNum">     129 </span>                :            : namespace protobuf {
<span class="lineNum">     130 </span>                :            : 
<span class="lineNum">     131 </span>                :            : // Defined in this file.
<span class="lineNum">     132 </span>                :            : class Message;
<span class="lineNum">     133 </span>                :            : class Reflection;
<span class="lineNum">     134 </span>                :            : class MessageFactory;
<span class="lineNum">     135 </span>                :            : 
<span class="lineNum">     136 </span>                :            : // Defined in other files.
<span class="lineNum">     137 </span>                :            : class MapKey;
<span class="lineNum">     138 </span>                :            : class MapValueRef;
<span class="lineNum">     139 </span>                :            : class MapIterator;
<span class="lineNum">     140 </span>                :            : class MapReflectionTester;
<span class="lineNum">     141 </span>                :            : 
<span class="lineNum">     142 </span>                :            : namespace internal {
<span class="lineNum">     143 </span>                :            : class MapFieldBase;
<span class="lineNum">     144 </span>                :            : }
<span class="lineNum">     145 </span>                :            : class UnknownFieldSet;         // unknown_field_set.h
<span class="lineNum">     146 </span>                :            : namespace io {
<span class="lineNum">     147 </span>                :            : class ZeroCopyInputStream;     // zero_copy_stream.h
<span class="lineNum">     148 </span>                :            : class ZeroCopyOutputStream;    // zero_copy_stream.h
<span class="lineNum">     149 </span>                :            : class CodedInputStream;        // coded_stream.h
<span class="lineNum">     150 </span>                :            : class CodedOutputStream;       // coded_stream.h
<span class="lineNum">     151 </span>                :            : }
<span class="lineNum">     152 </span>                :            : namespace python {
<span class="lineNum">     153 </span>                :            : class MapReflectionFriend;     // scalar_map_container.h
<span class="lineNum">     154 </span>                :            : }
<span class="lineNum">     155 </span>                :            : 
<span class="lineNum">     156 </span>                :            : 
<span class="lineNum">     157 </span>                :            : namespace internal {
<span class="lineNum">     158 </span>                :            : class ReflectionOps;     // reflection_ops.h
<span class="lineNum">     159 </span>                :            : class MapKeySorter;      // wire_format.cc
<span class="lineNum">     160 </span>                :            : class WireFormat;        // wire_format.h
<span class="lineNum">     161 </span>                :            : class MapFieldReflectionTest;  // map_test.cc
<span class="lineNum">     162 </span>                :            : }
<span class="lineNum">     163 </span>                :            : 
<span class="lineNum">     164 </span>                :            : template&lt;typename T&gt;
<span class="lineNum">     165 </span>                :            : class RepeatedField;     // repeated_field.h
<span class="lineNum">     166 </span>                :            : 
<span class="lineNum">     167 </span>                :            : template&lt;typename T&gt;
<span class="lineNum">     168 </span>                :            : class RepeatedPtrField;  // repeated_field.h
<span class="lineNum">     169 </span>                :            : 
<span class="lineNum">     170 </span>                :            : // A container to hold message metadata.
<span class="lineNum">     171 </span>                :            : struct Metadata {
<span class="lineNum">     172 </span>                :            :   const Descriptor* descriptor;
<span class="lineNum">     173 </span>                :            :   const Reflection* reflection;
<span class="lineNum">     174 </span>                :            : };
<span class="lineNum">     175 </span>                :            : 
<span class="lineNum">     176 </span>                :            : // Abstract interface for protocol messages.
<span class="lineNum">     177 </span>                :            : //
<span class="lineNum">     178 </span>                :            : // See also MessageLite, which contains most every-day operations.  Message
<span class="lineNum">     179 </span>                :            : // adds descriptors and reflection on top of that.
<span class="lineNum">     180 </span>                :            : //
<span class="lineNum">     181 </span>                :            : // The methods of this class that are virtual but not pure-virtual have
<span class="lineNum">     182 </span>                :            : // default implementations based on reflection.  Message classes which are
<span class="lineNum">     183 </span>                :            : // optimized for speed will want to override these with faster implementations,
<span class="lineNum">     184 </span>                :            : // but classes optimized for code size may be happy with keeping them.  See
<span class="lineNum">     185 </span>                :            : // the optimize_for option in descriptor.proto.
<a name="186"><span class="lineNum">     186 </span>                :            : class LIBPROTOBUF_EXPORT Message : public MessageLite {</a>
<a name="187"><span class="lineNum">     187 </span>                :            :  public:</a>
<span class="lineNum">     188 </span>                :<span class="lineCov">     688224 :   inline Message() {}</span>
<span class="lineNum">     189 </span>        [<span class="branchNoCov" title="Branch 3 was not taken"> - </span><span class="branchCov" title="Branch 4 was taken 336243 times"> + </span>]:<span class="lineCov">     672486 :   virtual ~Message() {}</span>
<span class="lineNum">     190 </span>                :            : 
<span class="lineNum">     191 </span>                :            :   // Basic Operations ------------------------------------------------
<span class="lineNum">     192 </span>                :            : 
<span class="lineNum">     193 </span>                :            :   // Construct a new instance of the same type.  Ownership is passed to the
<span class="lineNum">     194 </span>                :            :   // caller.  (This is also defined in MessageLite, but is defined again here
<span class="lineNum">     195 </span>                :            :   // for return-type covariance.)
<span class="lineNum">     196 </span>                :            :   virtual Message* New() const = 0;
<span class="lineNum">     197 </span>                :            : 
<span class="lineNum">     198 </span>                :            :   // Construct a new instance on the arena. Ownership is passed to the caller
<a name="199"><span class="lineNum">     199 </span>                :            :   // if arena is a NULL. Default implementation allows for API compatibility</a>
<span class="lineNum">     200 </span>                :            :   // during the Arena transition.
<span class="lineNum">     201 </span>                :<span class="lineNoCov">          0 :   virtual Message* New(::google::protobuf::Arena* arena) const {</span>
<span class="lineNum">     202 </span>                :<span class="lineNoCov">          0 :     Message* message = New();</span>
<span class="lineNum">     203 </span>        [<span class="branchNoExec" title="Branch 0 was not executed"> # </span><span class="branchNoExec" title="Branch 1 was not executed"> # </span>]:<span class="lineNoCov">          0 :     if (arena != NULL) {</span>
<span class="lineNum">     204 </span>                :<span class="lineNoCov">          0 :       arena-&gt;Own(message);</span>
<span class="lineNum">     205 </span>                :            :     }
<span class="lineNum">     206 </span>                :<span class="lineNoCov">          0 :     return message;</span>
<span class="lineNum">     207 </span>                :            :   }
<span class="lineNum">     208 </span>                :            : 
<span class="lineNum">     209 </span>                :            :   // Make this message into a copy of the given message.  The given message
<span class="lineNum">     210 </span>                :            :   // must have the same descriptor, but need not necessarily be the same class.
<span class="lineNum">     211 </span>                :            :   // By default this is just implemented as &quot;Clear(); MergeFrom(from);&quot;.
<span class="lineNum">     212 </span>                :            :   virtual void CopyFrom(const Message&amp; from);
<span class="lineNum">     213 </span>                :            : 
<span class="lineNum">     214 </span>                :            :   // Merge the fields from the given message into this message.  Singular
<span class="lineNum">     215 </span>                :            :   // fields will be overwritten, if specified in from, except for embedded
<span class="lineNum">     216 </span>                :            :   // messages which will be merged.  Repeated fields will be concatenated.
<span class="lineNum">     217 </span>                :            :   // The given message must be of the same type as this message (i.e. the
<span class="lineNum">     218 </span>                :            :   // exact same class).
<span class="lineNum">     219 </span>                :            :   virtual void MergeFrom(const Message&amp; from);
<span class="lineNum">     220 </span>                :            : 
<span class="lineNum">     221 </span>                :            :   // Verifies that IsInitialized() returns true.  GOOGLE_CHECK-fails otherwise, with
<span class="lineNum">     222 </span>                :            :   // a nice error message.
<span class="lineNum">     223 </span>                :            :   void CheckInitialized() const;
<span class="lineNum">     224 </span>                :            : 
<span class="lineNum">     225 </span>                :            :   // Slowly build a list of all required fields that are not set.
<span class="lineNum">     226 </span>                :            :   // This is much, much slower than IsInitialized() as it is implemented
<span class="lineNum">     227 </span>                :            :   // purely via reflection.  Generally, you should not call this unless you
<span class="lineNum">     228 </span>                :            :   // have already determined that an error exists by calling IsInitialized().
<span class="lineNum">     229 </span>                :            :   void FindInitializationErrors(std::vector&lt;string&gt;* errors) const;
<span class="lineNum">     230 </span>                :            : 
<span class="lineNum">     231 </span>                :            :   // Like FindInitializationErrors, but joins all the strings, delimited by
<span class="lineNum">     232 </span>                :            :   // commas, and returns them.
<span class="lineNum">     233 </span>                :            :   string InitializationErrorString() const;
<span class="lineNum">     234 </span>                :            : 
<span class="lineNum">     235 </span>                :            :   // Clears all unknown fields from this message and all embedded messages.
<span class="lineNum">     236 </span>                :            :   // Normally, if unknown tag numbers are encountered when parsing a message,
<span class="lineNum">     237 </span>                :            :   // the tag and value are stored in the message's UnknownFieldSet and
<span class="lineNum">     238 </span>                :            :   // then written back out when the message is serialized.  This allows servers
<span class="lineNum">     239 </span>                :            :   // which simply route messages to other servers to pass through messages
<span class="lineNum">     240 </span>                :            :   // that have new field definitions which they don't yet know about.  However,
<span class="lineNum">     241 </span>                :            :   // this behavior can have security implications.  To avoid it, call this
<span class="lineNum">     242 </span>                :            :   // method after parsing.
<span class="lineNum">     243 </span>                :            :   //
<span class="lineNum">     244 </span>                :            :   // See Reflection::GetUnknownFields() for more on unknown fields.
<span class="lineNum">     245 </span>                :            :   virtual void DiscardUnknownFields();
<span class="lineNum">     246 </span>                :            : 
<span class="lineNum">     247 </span>                :            :   // Computes (an estimate of) the total number of bytes currently used for
<span class="lineNum">     248 </span>                :            :   // storing the message in memory.  The default implementation calls the
<span class="lineNum">     249 </span>                :            :   // Reflection object's SpaceUsed() method.
<span class="lineNum">     250 </span>                :            :   //
<span class="lineNum">     251 </span>                :            :   // SpaceUsed() is noticeably slower than ByteSize(), as it is implemented
<span class="lineNum">     252 </span>                :            :   // using reflection (rather than the generated code implementation for
<span class="lineNum">     253 </span>                :            :   // ByteSize()). Like ByteSize(), its CPU time is linear in the number of
<span class="lineNum">     254 </span>                :            :   // fields defined for the proto.
<span class="lineNum">     255 </span>                :            :   virtual size_t SpaceUsedLong() const;
<span class="lineNum">     256 </span>                :            : 
<span class="lineNum">     257 </span>                :            :   int SpaceUsed() const { return internal::ToIntSize(SpaceUsedLong()); }
<span class="lineNum">     258 </span>                :            : 
<span class="lineNum">     259 </span>                :            :   // Debugging &amp; Testing----------------------------------------------
<span class="lineNum">     260 </span>                :            : 
<span class="lineNum">     261 </span>                :            :   // Generates a human readable form of this message, useful for debugging
<span class="lineNum">     262 </span>                :            :   // and other purposes.
<span class="lineNum">     263 </span>                :            :   string DebugString() const;
<span class="lineNum">     264 </span>                :            :   // Like DebugString(), but with less whitespace.
<span class="lineNum">     265 </span>                :            :   string ShortDebugString() const;
<span class="lineNum">     266 </span>                :            :   // Like DebugString(), but do not escape UTF-8 byte sequences.
<span class="lineNum">     267 </span>                :            :   string Utf8DebugString() const;
<span class="lineNum">     268 </span>                :            :   // Convenience function useful in GDB.  Prints DebugString() to stdout.
<span class="lineNum">     269 </span>                :            :   void PrintDebugString() const;
<span class="lineNum">     270 </span>                :            : 
<span class="lineNum">     271 </span>                :            :   // Heavy I/O -------------------------------------------------------
<span class="lineNum">     272 </span>                :            :   // Additional parsing and serialization methods not implemented by
<span class="lineNum">     273 </span>                :            :   // MessageLite because they are not supported by the lite library.
<span class="lineNum">     274 </span>                :            : 
<span class="lineNum">     275 </span>                :            :   // Parse a protocol buffer from a file descriptor.  If successful, the entire
<span class="lineNum">     276 </span>                :            :   // input will be consumed.
<span class="lineNum">     277 </span>                :            :   bool ParseFromFileDescriptor(int file_descriptor);
<span class="lineNum">     278 </span>                :            :   // Like ParseFromFileDescriptor(), but accepts messages that are missing
<span class="lineNum">     279 </span>                :            :   // required fields.
<span class="lineNum">     280 </span>                :            :   bool ParsePartialFromFileDescriptor(int file_descriptor);
<span class="lineNum">     281 </span>                :            :   // Parse a protocol buffer from a C++ istream.  If successful, the entire
<span class="lineNum">     282 </span>                :            :   // input will be consumed.
<span class="lineNum">     283 </span>                :            :   bool ParseFromIstream(std::istream* input);
<span class="lineNum">     284 </span>                :            :   // Like ParseFromIstream(), but accepts messages that are missing
<span class="lineNum">     285 </span>                :            :   // required fields.
<span class="lineNum">     286 </span>                :            :   bool ParsePartialFromIstream(std::istream* input);
<span class="lineNum">     287 </span>                :            : 
<span class="lineNum">     288 </span>                :            :   // Serialize the message and write it to the given file descriptor.  All
<span class="lineNum">     289 </span>                :            :   // required fields must be set.
<span class="lineNum">     290 </span>                :            :   bool SerializeToFileDescriptor(int file_descriptor) const;
<span class="lineNum">     291 </span>                :            :   // Like SerializeToFileDescriptor(), but allows missing required fields.
<span class="lineNum">     292 </span>                :            :   bool SerializePartialToFileDescriptor(int file_descriptor) const;
<span class="lineNum">     293 </span>                :            :   // Serialize the message and write it to the given C++ ostream.  All
<span class="lineNum">     294 </span>                :            :   // required fields must be set.
<span class="lineNum">     295 </span>                :            :   bool SerializeToOstream(std::ostream* output) const;
<span class="lineNum">     296 </span>                :            :   // Like SerializeToOstream(), but allows missing required fields.
<span class="lineNum">     297 </span>                :            :   bool SerializePartialToOstream(std::ostream* output) const;
<span class="lineNum">     298 </span>                :            : 
<span class="lineNum">     299 </span>                :            : 
<span class="lineNum">     300 </span>                :            :   // Reflection-based methods ----------------------------------------
<span class="lineNum">     301 </span>                :            :   // These methods are pure-virtual in MessageLite, but Message provides
<span class="lineNum">     302 </span>                :            :   // reflection-based default implementations.
<span class="lineNum">     303 </span>                :            : 
<span class="lineNum">     304 </span>                :            :   virtual string GetTypeName() const;
<span class="lineNum">     305 </span>                :            :   virtual void Clear();
<span class="lineNum">     306 </span>                :            :   virtual bool IsInitialized() const;
<span class="lineNum">     307 </span>                :            :   virtual void CheckTypeAndMergeFrom(const MessageLite&amp; other);
<span class="lineNum">     308 </span>                :            :   virtual bool MergePartialFromCodedStream(io::CodedInputStream* input);
<span class="lineNum">     309 </span>                :            :   virtual size_t ByteSizeLong() const;
<span class="lineNum">     310 </span>                :            :   virtual void SerializeWithCachedSizes(io::CodedOutputStream* output) const;
<span class="lineNum">     311 </span>                :            : 
<span class="lineNum">     312 </span>                :            :  private:
<span class="lineNum">     313 </span>                :            :   // This is called only by the default implementation of ByteSize(), to
<span class="lineNum">     314 </span>                :            :   // update the cached size.  If you override ByteSize(), you do not need
<span class="lineNum">     315 </span>                :            :   // to override this.  If you do not override ByteSize(), you MUST override
<span class="lineNum">     316 </span>                :            :   // this; the default implementation will crash.
<span class="lineNum">     317 </span>                :            :   //
<span class="lineNum">     318 </span>                :            :   // The method is private because subclasses should never call it; only
<span class="lineNum">     319 </span>                :            :   // override it.  Yes, C++ lets you do that.  Crazy, huh?
<span class="lineNum">     320 </span>                :            :   virtual void SetCachedSize(int size) const;
<span class="lineNum">     321 </span>                :            : 
<span class="lineNum">     322 </span>                :            :  public:
<span class="lineNum">     323 </span>                :            : 
<span class="lineNum">     324 </span>                :            :   // Introspection ---------------------------------------------------
<span class="lineNum">     325 </span>                :            : 
<span class="lineNum">     326 </span>                :            :   // Typedef for backwards-compatibility.
<span class="lineNum">     327 </span>                :            :   typedef google::protobuf::Reflection Reflection;
<span class="lineNum">     328 </span>                :            : 
<a name="329"><span class="lineNum">     329 </span>                :            :   // Get a Descriptor for this message's type.  This describes what</a>
<span class="lineNum">     330 </span>                :            :   // fields the message contains, the types of those fields, etc.
<span class="lineNum">     331 </span>                :<span class="lineCov">      89390 :   const Descriptor* GetDescriptor() const { return GetMetadata().descriptor; }</span>
<span class="lineNum">     332 </span>                :            : 
<span class="lineNum">     333 </span>                :            :   // Get the Reflection interface for this Message, which can be used to
<span class="lineNum">     334 </span>                :            :   // read and modify the fields of the Message dynamically (in other words,
<span class="lineNum">     335 </span>                :            :   // without knowing the message type at compile time).  This object remains
<span class="lineNum">     336 </span>                :            :   // property of the Message.
<span class="lineNum">     337 </span>                :            :   //
<a name="338"><span class="lineNum">     338 </span>                :            :   // This method remains virtual in case a subclass does not implement</a>
<span class="lineNum">     339 </span>                :            :   // reflection and wants to override the default behavior.
<span class="lineNum">     340 </span>                :<span class="lineCov">       7971 :   virtual const Reflection* GetReflection() const {</span>
<span class="lineNum">     341 </span>                :<span class="lineCov">       7971 :     return GetMetadata().reflection;</span>
<span class="lineNum">     342 </span>                :            :   }
<span class="lineNum">     343 </span>                :            : 
<span class="lineNum">     344 </span>                :            :  protected:
<span class="lineNum">     345 </span>                :            :   // Get a struct containing the metadata for the Message. Most subclasses only
<span class="lineNum">     346 </span>                :            :   // need to implement this method, rather than the GetDescriptor() and
<span class="lineNum">     347 </span>                :            :   // GetReflection() wrappers.
<span class="lineNum">     348 </span>                :            :   virtual Metadata GetMetadata() const  = 0;
<span class="lineNum">     349 </span>                :            : 
<span class="lineNum">     350 </span>                :            : 
<span class="lineNum">     351 </span>                :            :  private:
<span class="lineNum">     352 </span>                :            :   GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(Message);
<span class="lineNum">     353 </span>                :            : };
<span class="lineNum">     354 </span>                :            : 
<span class="lineNum">     355 </span>                :            : namespace internal {
<span class="lineNum">     356 </span>                :            : // Forward-declare interfaces used to implement RepeatedFieldRef.
<span class="lineNum">     357 </span>                :            : // These are protobuf internals that users shouldn't care about.
<span class="lineNum">     358 </span>                :            : class RepeatedFieldAccessor;
<span class="lineNum">     359 </span>                :            : }  // namespace internal
<span class="lineNum">     360 </span>                :            : 
<span class="lineNum">     361 </span>                :            : // Forward-declare RepeatedFieldRef templates. The second type parameter is
<span class="lineNum">     362 </span>                :            : // used for SFINAE tricks. Users should ignore it.
<span class="lineNum">     363 </span>                :            : template&lt;typename T, typename Enable = void&gt;
<span class="lineNum">     364 </span>                :            : class RepeatedFieldRef;
<span class="lineNum">     365 </span>                :            : 
<span class="lineNum">     366 </span>                :            : template&lt;typename T, typename Enable = void&gt;
<span class="lineNum">     367 </span>                :            : class MutableRepeatedFieldRef;
<span class="lineNum">     368 </span>                :            : 
<span class="lineNum">     369 </span>                :            : // This interface contains methods that can be used to dynamically access
<span class="lineNum">     370 </span>                :            : // and modify the fields of a protocol message.  Their semantics are
<span class="lineNum">     371 </span>                :            : // similar to the accessors the protocol compiler generates.
<span class="lineNum">     372 </span>                :            : //
<span class="lineNum">     373 </span>                :            : // To get the Reflection for a given Message, call Message::GetReflection().
<span class="lineNum">     374 </span>                :            : //
<span class="lineNum">     375 </span>                :            : // This interface is separate from Message only for efficiency reasons;
<span class="lineNum">     376 </span>                :            : // the vast majority of implementations of Message will share the same
<span class="lineNum">     377 </span>                :            : // implementation of Reflection (GeneratedMessageReflection,
<span class="lineNum">     378 </span>                :            : // defined in generated_message.h), and all Messages of a particular class
<span class="lineNum">     379 </span>                :            : // should share the same Reflection object (though you should not rely on
<span class="lineNum">     380 </span>                :            : // the latter fact).
<span class="lineNum">     381 </span>                :            : //
<span class="lineNum">     382 </span>                :            : // There are several ways that these methods can be used incorrectly.  For
<span class="lineNum">     383 </span>                :            : // example, any of the following conditions will lead to undefined
<span class="lineNum">     384 </span>                :            : // results (probably assertion failures):
<span class="lineNum">     385 </span>                :            : // - The FieldDescriptor is not a field of this message type.
<span class="lineNum">     386 </span>                :            : // - The method called is not appropriate for the field's type.  For
<span class="lineNum">     387 </span>                :            : //   each field type in FieldDescriptor::TYPE_*, there is only one
<span class="lineNum">     388 </span>                :            : //   Get*() method, one Set*() method, and one Add*() method that is
<span class="lineNum">     389 </span>                :            : //   valid for that type.  It should be obvious which (except maybe
<span class="lineNum">     390 </span>                :            : //   for TYPE_BYTES, which are represented using strings in C++).
<span class="lineNum">     391 </span>                :            : // - A Get*() or Set*() method for singular fields is called on a repeated
<span class="lineNum">     392 </span>                :            : //   field.
<span class="lineNum">     393 </span>                :            : // - GetRepeated*(), SetRepeated*(), or Add*() is called on a non-repeated
<span class="lineNum">     394 </span>                :            : //   field.
<span class="lineNum">     395 </span>                :            : // - The Message object passed to any method is not of the right type for
<span class="lineNum">     396 </span>                :            : //   this Reflection object (i.e. message.GetReflection() != reflection).
<span class="lineNum">     397 </span>                :            : //
<span class="lineNum">     398 </span>                :            : // You might wonder why there is not any abstract representation for a field
<span class="lineNum">     399 </span>                :            : // of arbitrary type.  E.g., why isn't there just a &quot;GetField()&quot; method that
<span class="lineNum">     400 </span>                :            : // returns &quot;const Field&amp;&quot;, where &quot;Field&quot; is some class with accessors like
<span class="lineNum">     401 </span>                :            : // &quot;GetInt32Value()&quot;.  The problem is that someone would have to deal with
<span class="lineNum">     402 </span>                :            : // allocating these Field objects.  For generated message classes, having to
<span class="lineNum">     403 </span>                :            : // allocate space for an additional object to wrap every field would at least
<span class="lineNum">     404 </span>                :            : // double the message's memory footprint, probably worse.  Allocating the
<span class="lineNum">     405 </span>                :            : // objects on-demand, on the other hand, would be expensive and prone to
<span class="lineNum">     406 </span>                :            : // memory leaks.  So, instead we ended up with this flat interface.
<span class="lineNum">     407 </span>                :            : //
<span class="lineNum">     408 </span>                :            : // TODO(kenton):  Create a utility class which callers can use to read and
<span class="lineNum">     409 </span>                :            : //   write fields from a Reflection without paying attention to the type.
<span class="lineNum">     410 </span>                :            : class LIBPROTOBUF_EXPORT Reflection {
<span class="lineNum">     411 </span>                :            :  public:
<span class="lineNum">     412 </span>                :            :   inline Reflection() {}
<span class="lineNum">     413 </span>                :            :   virtual ~Reflection();
<span class="lineNum">     414 </span>                :            : 
<span class="lineNum">     415 </span>                :            :   // Get the UnknownFieldSet for the message.  This contains fields which
<span class="lineNum">     416 </span>                :            :   // were seen when the Message was parsed but were not recognized according
<span class="lineNum">     417 </span>                :            :   // to the Message's definition. For proto3 protos, this method will always
<span class="lineNum">     418 </span>                :            :   // return an empty UnknownFieldSet.
<span class="lineNum">     419 </span>                :            :   virtual const UnknownFieldSet&amp; GetUnknownFields(
<span class="lineNum">     420 </span>                :            :       const Message&amp; message) const = 0;
<span class="lineNum">     421 </span>                :            :   // Get a mutable pointer to the UnknownFieldSet for the message.  This
<span class="lineNum">     422 </span>                :            :   // contains fields which were seen when the Message was parsed but were not
<span class="lineNum">     423 </span>                :            :   // recognized according to the Message's definition. For proto3 protos, this
<span class="lineNum">     424 </span>                :            :   // method will return a valid mutable UnknownFieldSet pointer but modifying
<span class="lineNum">     425 </span>                :            :   // it won't affect the serialized bytes of the message.
<span class="lineNum">     426 </span>                :            :   virtual UnknownFieldSet* MutableUnknownFields(Message* message) const = 0;
<span class="lineNum">     427 </span>                :            : 
<span class="lineNum">     428 </span>                :            :   // Estimate the amount of memory used by the message object.
<span class="lineNum">     429 </span>                :            :   virtual size_t SpaceUsedLong(const Message&amp; message) const = 0;
<span class="lineNum">     430 </span>                :            : 
<span class="lineNum">     431 </span>                :            :   int SpaceUsed(const Message&amp; message) const {
<span class="lineNum">     432 </span>                :            :     return internal::ToIntSize(SpaceUsedLong(message));
<span class="lineNum">     433 </span>                :            :   }
<span class="lineNum">     434 </span>                :            : 
<span class="lineNum">     435 </span>                :            :   // Check if the given non-repeated field is set.
<span class="lineNum">     436 </span>                :            :   virtual bool HasField(const Message&amp; message,
<span class="lineNum">     437 </span>                :            :                         const FieldDescriptor* field) const = 0;
<span class="lineNum">     438 </span>                :            : 
<span class="lineNum">     439 </span>                :            :   // Get the number of elements of a repeated field.
<span class="lineNum">     440 </span>                :            :   virtual int FieldSize(const Message&amp; message,
<span class="lineNum">     441 </span>                :            :                         const FieldDescriptor* field) const = 0;
<span class="lineNum">     442 </span>                :            : 
<span class="lineNum">     443 </span>                :            :   // Clear the value of a field, so that HasField() returns false or
<span class="lineNum">     444 </span>                :            :   // FieldSize() returns zero.
<span class="lineNum">     445 </span>                :            :   virtual void ClearField(Message* message,
<span class="lineNum">     446 </span>                :            :                           const FieldDescriptor* field) const = 0;
<span class="lineNum">     447 </span>                :            : 
<span class="lineNum">     448 </span>                :            :   // Check if the oneof is set. Returns true if any field in oneof
<span class="lineNum">     449 </span>                :            :   // is set, false otherwise.
<span class="lineNum">     450 </span>                :            :   // TODO(jieluo) - make it pure virtual after updating all
<span class="lineNum">     451 </span>                :            :   // the subclasses.
<span class="lineNum">     452 </span>                :            :   virtual bool HasOneof(const Message&amp; /*message*/,
<span class="lineNum">     453 </span>                :            :                         const OneofDescriptor* /*oneof_descriptor*/) const {
<span class="lineNum">     454 </span>                :            :     return false;
<span class="lineNum">     455 </span>                :            :   }
<span class="lineNum">     456 </span>                :            : 
<span class="lineNum">     457 </span>                :            :   virtual void ClearOneof(Message* /*message*/,
<span class="lineNum">     458 </span>                :            :                           const OneofDescriptor* /*oneof_descriptor*/) const {}
<span class="lineNum">     459 </span>                :            : 
<span class="lineNum">     460 </span>                :            :   // Returns the field descriptor if the oneof is set. NULL otherwise.
<span class="lineNum">     461 </span>                :            :   // TODO(jieluo) - make it pure virtual.
<span class="lineNum">     462 </span>                :            :   virtual const FieldDescriptor* GetOneofFieldDescriptor(
<span class="lineNum">     463 </span>                :            :       const Message&amp; /*message*/,
<span class="lineNum">     464 </span>                :            :       const OneofDescriptor* /*oneof_descriptor*/) const {
<span class="lineNum">     465 </span>                :            :     return NULL;
<span class="lineNum">     466 </span>                :            :   }
<span class="lineNum">     467 </span>                :            : 
<span class="lineNum">     468 </span>                :            :   // Removes the last element of a repeated field.
<span class="lineNum">     469 </span>                :            :   // We don't provide a way to remove any element other than the last
<span class="lineNum">     470 </span>                :            :   // because it invites inefficient use, such as O(n^2) filtering loops
<span class="lineNum">     471 </span>                :            :   // that should have been O(n).  If you want to remove an element other
<span class="lineNum">     472 </span>                :            :   // than the last, the best way to do it is to re-arrange the elements
<span class="lineNum">     473 </span>                :            :   // (using Swap()) so that the one you want removed is at the end, then
<span class="lineNum">     474 </span>                :            :   // call RemoveLast().
<span class="lineNum">     475 </span>                :            :   virtual void RemoveLast(Message* message,
<span class="lineNum">     476 </span>                :            :                           const FieldDescriptor* field) const = 0;
<span class="lineNum">     477 </span>                :            :   // Removes the last element of a repeated message field, and returns the
<span class="lineNum">     478 </span>                :            :   // pointer to the caller.  Caller takes ownership of the returned pointer.
<span class="lineNum">     479 </span>                :            :   virtual Message* ReleaseLast(Message* message,
<span class="lineNum">     480 </span>                :            :                                const FieldDescriptor* field) const = 0;
<span class="lineNum">     481 </span>                :            : 
<span class="lineNum">     482 </span>                :            :   // Swap the complete contents of two messages.
<span class="lineNum">     483 </span>                :            :   virtual void Swap(Message* message1, Message* message2) const = 0;
<span class="lineNum">     484 </span>                :            : 
<span class="lineNum">     485 </span>                :            :   // Swap fields listed in fields vector of two messages.
<span class="lineNum">     486 </span>                :            :   virtual void SwapFields(Message* message1,
<span class="lineNum">     487 </span>                :            :                           Message* message2,
<span class="lineNum">     488 </span>                :            :                           const std::vector&lt;const FieldDescriptor*&gt;&amp; fields)
<span class="lineNum">     489 </span>                :            :       const = 0;
<span class="lineNum">     490 </span>                :            : 
<span class="lineNum">     491 </span>                :            :   // Swap two elements of a repeated field.
<span class="lineNum">     492 </span>                :            :   virtual void SwapElements(Message* message,
<span class="lineNum">     493 </span>                :            :                             const FieldDescriptor* field,
<span class="lineNum">     494 </span>                :            :                             int index1,
<span class="lineNum">     495 </span>                :            :                             int index2) const = 0;
<span class="lineNum">     496 </span>                :            : 
<span class="lineNum">     497 </span>                :            :   // List all fields of the message which are currently set.  This includes
<span class="lineNum">     498 </span>                :            :   // extensions.  Singular fields will only be listed if HasField(field) would
<span class="lineNum">     499 </span>                :            :   // return true and repeated fields will only be listed if FieldSize(field)
<span class="lineNum">     500 </span>                :            :   // would return non-zero.  Fields (both normal fields and extension fields)
<span class="lineNum">     501 </span>                :            :   // will be listed ordered by field number.
<span class="lineNum">     502 </span>                :            :   virtual void ListFields(
<span class="lineNum">     503 </span>                :            :       const Message&amp; message,
<span class="lineNum">     504 </span>                :            :       std::vector&lt;const FieldDescriptor*&gt;* output) const = 0;
<span class="lineNum">     505 </span>                :            : 
<span class="lineNum">     506 </span>                :            :   // Singular field getters ------------------------------------------
<span class="lineNum">     507 </span>                :            :   // These get the value of a non-repeated field.  They return the default
<span class="lineNum">     508 </span>                :            :   // value for fields that aren't set.
<span class="lineNum">     509 </span>                :            : 
<span class="lineNum">     510 </span>                :            :   virtual int32  GetInt32 (const Message&amp; message,
<span class="lineNum">     511 </span>                :            :                            const FieldDescriptor* field) const = 0;
<span class="lineNum">     512 </span>                :            :   virtual int64  GetInt64 (const Message&amp; message,
<span class="lineNum">     513 </span>                :            :                            const FieldDescriptor* field) const = 0;
<span class="lineNum">     514 </span>                :            :   virtual uint32 GetUInt32(const Message&amp; message,
<span class="lineNum">     515 </span>                :            :                            const FieldDescriptor* field) const = 0;
<span class="lineNum">     516 </span>                :            :   virtual uint64 GetUInt64(const Message&amp; message,
<span class="lineNum">     517 </span>                :            :                            const FieldDescriptor* field) const = 0;
<span class="lineNum">     518 </span>                :            :   virtual float  GetFloat (const Message&amp; message,
<span class="lineNum">     519 </span>                :            :                            const FieldDescriptor* field) const = 0;
<span class="lineNum">     520 </span>                :            :   virtual double GetDouble(const Message&amp; message,
<span class="lineNum">     521 </span>                :            :                            const FieldDescriptor* field) const = 0;
<span class="lineNum">     522 </span>                :            :   virtual bool   GetBool  (const Message&amp; message,
<span class="lineNum">     523 </span>                :            :                            const FieldDescriptor* field) const = 0;
<span class="lineNum">     524 </span>                :            :   virtual string GetString(const Message&amp; message,
<span class="lineNum">     525 </span>                :            :                            const FieldDescriptor* field) const = 0;
<span class="lineNum">     526 </span>                :            :   virtual const EnumValueDescriptor* GetEnum(
<span class="lineNum">     527 </span>                :            :       const Message&amp; message, const FieldDescriptor* field) const = 0;
<span class="lineNum">     528 </span>                :            : 
<span class="lineNum">     529 </span>                :            :   // GetEnumValue() returns an enum field's value as an integer rather than
<span class="lineNum">     530 </span>                :            :   // an EnumValueDescriptor*. If the integer value does not correspond to a
<span class="lineNum">     531 </span>                :            :   // known value descriptor, a new value descriptor is created. (Such a value
<span class="lineNum">     532 </span>                :            :   // will only be present when the new unknown-enum-value semantics are enabled
<span class="lineNum">     533 </span>                :            :   // for a message.)
<span class="lineNum">     534 </span>                :            :   virtual int GetEnumValue(
<span class="lineNum">     535 </span>                :            :       const Message&amp; message, const FieldDescriptor* field) const = 0;
<span class="lineNum">     536 </span>                :            : 
<span class="lineNum">     537 </span>                :            :   // See MutableMessage() for the meaning of the &quot;factory&quot; parameter.
<span class="lineNum">     538 </span>                :            :   virtual const Message&amp; GetMessage(const Message&amp; message,
<span class="lineNum">     539 </span>                :            :                                     const FieldDescriptor* field,
<span class="lineNum">     540 </span>                :            :                                     MessageFactory* factory = NULL) const = 0;
<span class="lineNum">     541 </span>                :            : 
<span class="lineNum">     542 </span>                :            :   // Get a string value without copying, if possible.
<span class="lineNum">     543 </span>                :            :   //
<span class="lineNum">     544 </span>                :            :   // GetString() necessarily returns a copy of the string.  This can be
<span class="lineNum">     545 </span>                :            :   // inefficient when the string is already stored in a string object in the
<span class="lineNum">     546 </span>                :            :   // underlying message.  GetStringReference() will return a reference to the
<span class="lineNum">     547 </span>                :            :   // underlying string in this case.  Otherwise, it will copy the string into
<span class="lineNum">     548 </span>                :            :   // *scratch and return that.
<span class="lineNum">     549 </span>                :            :   //
<span class="lineNum">     550 </span>                :            :   // Note:  It is perfectly reasonable and useful to write code like:
<span class="lineNum">     551 </span>                :            :   //     str = reflection-&gt;GetStringReference(field, &amp;str);
<span class="lineNum">     552 </span>                :            :   //   This line would ensure that only one copy of the string is made
<span class="lineNum">     553 </span>                :            :   //   regardless of the field's underlying representation.  When initializing
<span class="lineNum">     554 </span>                :            :   //   a newly-constructed string, though, it's just as fast and more readable
<span class="lineNum">     555 </span>                :            :   //   to use code like:
<span class="lineNum">     556 </span>                :            :   //     string str = reflection-&gt;GetString(message, field);
<span class="lineNum">     557 </span>                :            :   virtual const string&amp; GetStringReference(const Message&amp; message,
<span class="lineNum">     558 </span>                :            :                                            const FieldDescriptor* field,
<span class="lineNum">     559 </span>                :            :                                            string* scratch) const = 0;
<span class="lineNum">     560 </span>                :            : 
<span class="lineNum">     561 </span>                :            : 
<span class="lineNum">     562 </span>                :            :   // Singular field mutators -----------------------------------------
<span class="lineNum">     563 </span>                :            :   // These mutate the value of a non-repeated field.
<span class="lineNum">     564 </span>                :            : 
<span class="lineNum">     565 </span>                :            :   virtual void SetInt32 (Message* message,
<span class="lineNum">     566 </span>                :            :                          const FieldDescriptor* field, int32  value) const = 0;
<span class="lineNum">     567 </span>                :            :   virtual void SetInt64 (Message* message,
<span class="lineNum">     568 </span>                :            :                          const FieldDescriptor* field, int64  value) const = 0;
<span class="lineNum">     569 </span>                :            :   virtual void SetUInt32(Message* message,
<span class="lineNum">     570 </span>                :            :                          const FieldDescriptor* field, uint32 value) const = 0;
<span class="lineNum">     571 </span>                :            :   virtual void SetUInt64(Message* message,
<span class="lineNum">     572 </span>                :            :                          const FieldDescriptor* field, uint64 value) const = 0;
<span class="lineNum">     573 </span>                :            :   virtual void SetFloat (Message* message,
<span class="lineNum">     574 </span>                :            :                          const FieldDescriptor* field, float  value) const = 0;
<span class="lineNum">     575 </span>                :            :   virtual void SetDouble(Message* message,
<span class="lineNum">     576 </span>                :            :                          const FieldDescriptor* field, double value) const = 0;
<span class="lineNum">     577 </span>                :            :   virtual void SetBool  (Message* message,
<span class="lineNum">     578 </span>                :            :                          const FieldDescriptor* field, bool   value) const = 0;
<span class="lineNum">     579 </span>                :            :   virtual void SetString(Message* message,
<span class="lineNum">     580 </span>                :            :                          const FieldDescriptor* field,
<span class="lineNum">     581 </span>                :            :                          const string&amp; value) const = 0;
<span class="lineNum">     582 </span>                :            :   virtual void SetEnum  (Message* message,
<span class="lineNum">     583 </span>                :            :                          const FieldDescriptor* field,
<span class="lineNum">     584 </span>                :            :                          const EnumValueDescriptor* value) const = 0;
<span class="lineNum">     585 </span>                :            :   // Set an enum field's value with an integer rather than EnumValueDescriptor.
<span class="lineNum">     586 </span>                :            :   // If the value does not correspond to a known enum value, either behavior is
<span class="lineNum">     587 </span>                :            :   // undefined (for proto2 messages), or the value is accepted silently for
<span class="lineNum">     588 </span>                :            :   // messages with new unknown-enum-value semantics.
<span class="lineNum">     589 </span>                :            :   virtual void SetEnumValue(Message* message,
<span class="lineNum">     590 </span>                :            :                             const FieldDescriptor* field,
<span class="lineNum">     591 </span>                :            :                             int value) const = 0;
<span class="lineNum">     592 </span>                :            : 
<span class="lineNum">     593 </span>                :            :   // Get a mutable pointer to a field with a message type.  If a MessageFactory
<span class="lineNum">     594 </span>                :            :   // is provided, it will be used to construct instances of the sub-message;
<span class="lineNum">     595 </span>                :            :   // otherwise, the default factory is used.  If the field is an extension that
<span class="lineNum">     596 </span>                :            :   // does not live in the same pool as the containing message's descriptor (e.g.
<span class="lineNum">     597 </span>                :            :   // it lives in an overlay pool), then a MessageFactory must be provided.
<span class="lineNum">     598 </span>                :            :   // If you have no idea what that meant, then you probably don't need to worry
<span class="lineNum">     599 </span>                :            :   // about it (don't provide a MessageFactory).  WARNING:  If the
<span class="lineNum">     600 </span>                :            :   // FieldDescriptor is for a compiled-in extension, then
<span class="lineNum">     601 </span>                :            :   // factory-&gt;GetPrototype(field-&gt;message_type()) MUST return an instance of
<span class="lineNum">     602 </span>                :            :   // the compiled-in class for this type, NOT DynamicMessage.
<span class="lineNum">     603 </span>                :            :   virtual Message* MutableMessage(Message* message,
<span class="lineNum">     604 </span>                :            :                                   const FieldDescriptor* field,
<span class="lineNum">     605 </span>                :            :                                   MessageFactory* factory = NULL) const = 0;
<span class="lineNum">     606 </span>                :            :   // Replaces the message specified by 'field' with the already-allocated object
<span class="lineNum">     607 </span>                :            :   // sub_message, passing ownership to the message.  If the field contained a
<span class="lineNum">     608 </span>                :            :   // message, that message is deleted.  If sub_message is NULL, the field is
<span class="lineNum">     609 </span>                :            :   // cleared.
<span class="lineNum">     610 </span>                :            :   virtual void SetAllocatedMessage(Message* message,
<span class="lineNum">     611 </span>                :            :                                    Message* sub_message,
<span class="lineNum">     612 </span>                :            :                                    const FieldDescriptor* field) const = 0;
<span class="lineNum">     613 </span>                :            :   // Releases the message specified by 'field' and returns the pointer,
<span class="lineNum">     614 </span>                :            :   // ReleaseMessage() will return the message the message object if it exists.
<span class="lineNum">     615 </span>                :            :   // Otherwise, it may or may not return NULL.  In any case, if the return value
<span class="lineNum">     616 </span>                :            :   // is non-NULL, the caller takes ownership of the pointer.
<span class="lineNum">     617 </span>                :            :   // If the field existed (HasField() is true), then the returned pointer will
<span class="lineNum">     618 </span>                :            :   // be the same as the pointer returned by MutableMessage().
<span class="lineNum">     619 </span>                :            :   // This function has the same effect as ClearField().
<span class="lineNum">     620 </span>                :            :   virtual Message* ReleaseMessage(Message* message,
<span class="lineNum">     621 </span>                :            :                                   const FieldDescriptor* field,
<span class="lineNum">     622 </span>                :            :                                   MessageFactory* factory = NULL) const = 0;
<span class="lineNum">     623 </span>                :            : 
<span class="lineNum">     624 </span>                :            : 
<span class="lineNum">     625 </span>                :            :   // Repeated field getters ------------------------------------------
<span class="lineNum">     626 </span>                :            :   // These get the value of one element of a repeated field.
<span class="lineNum">     627 </span>                :            : 
<span class="lineNum">     628 </span>                :            :   virtual int32  GetRepeatedInt32 (const Message&amp; message,
<span class="lineNum">     629 </span>                :            :                                    const FieldDescriptor* field,
<span class="lineNum">     630 </span>                :            :                                    int index) const = 0;
<span class="lineNum">     631 </span>                :            :   virtual int64  GetRepeatedInt64 (const Message&amp; message,
<span class="lineNum">     632 </span>                :            :                                    const FieldDescriptor* field,
<span class="lineNum">     633 </span>                :            :                                    int index) const = 0;
<span class="lineNum">     634 </span>                :            :   virtual uint32 GetRepeatedUInt32(const Message&amp; message,
<span class="lineNum">     635 </span>                :            :                                    const FieldDescriptor* field,
<span class="lineNum">     636 </span>                :            :                                    int index) const = 0;
<span class="lineNum">     637 </span>                :            :   virtual uint64 GetRepeatedUInt64(const Message&amp; message,
<span class="lineNum">     638 </span>                :            :                                    const FieldDescriptor* field,
<span class="lineNum">     639 </span>                :            :                                    int index) const = 0;
<span class="lineNum">     640 </span>                :            :   virtual float  GetRepeatedFloat (const Message&amp; message,
<span class="lineNum">     641 </span>                :            :                                    const FieldDescriptor* field,
<span class="lineNum">     642 </span>                :            :                                    int index) const = 0;
<span class="lineNum">     643 </span>                :            :   virtual double GetRepeatedDouble(const Message&amp; message,
<span class="lineNum">     644 </span>                :            :                                    const FieldDescriptor* field,
<span class="lineNum">     645 </span>                :            :                                    int index) const = 0;
<span class="lineNum">     646 </span>                :            :   virtual bool   GetRepeatedBool  (const Message&amp; message,
<span class="lineNum">     647 </span>                :            :                                    const FieldDescriptor* field,
<span class="lineNum">     648 </span>                :            :                                    int index) const = 0;
<span class="lineNum">     649 </span>                :            :   virtual string GetRepeatedString(const Message&amp; message,
<span class="lineNum">     650 </span>                :            :                                    const FieldDescriptor* field,
<span class="lineNum">     651 </span>                :            :                                    int index) const = 0;
<span class="lineNum">     652 </span>                :            :   virtual const EnumValueDescriptor* GetRepeatedEnum(
<span class="lineNum">     653 </span>                :            :       const Message&amp; message,
<span class="lineNum">     654 </span>                :            :       const FieldDescriptor* field, int index) const = 0;
<span class="lineNum">     655 </span>                :            :   // GetRepeatedEnumValue() returns an enum field's value as an integer rather
<span class="lineNum">     656 </span>                :            :   // than an EnumValueDescriptor*. If the integer value does not correspond to a
<span class="lineNum">     657 </span>                :            :   // known value descriptor, a new value descriptor is created. (Such a value
<span class="lineNum">     658 </span>                :            :   // will only be present when the new unknown-enum-value semantics are enabled
<span class="lineNum">     659 </span>                :            :   // for a message.)
<span class="lineNum">     660 </span>                :            :   virtual int GetRepeatedEnumValue(
<span class="lineNum">     661 </span>                :            :       const Message&amp; message,
<span class="lineNum">     662 </span>                :            :       const FieldDescriptor* field, int index) const = 0;
<span class="lineNum">     663 </span>                :            :   virtual const Message&amp; GetRepeatedMessage(
<span class="lineNum">     664 </span>                :            :       const Message&amp; message,
<span class="lineNum">     665 </span>                :            :       const FieldDescriptor* field, int index) const = 0;
<span class="lineNum">     666 </span>                :            : 
<span class="lineNum">     667 </span>                :            :   // See GetStringReference(), above.
<span class="lineNum">     668 </span>                :            :   virtual const string&amp; GetRepeatedStringReference(
<span class="lineNum">     669 </span>                :            :       const Message&amp; message, const FieldDescriptor* field,
<span class="lineNum">     670 </span>                :            :       int index, string* scratch) const = 0;
<span class="lineNum">     671 </span>                :            : 
<span class="lineNum">     672 </span>                :            : 
<span class="lineNum">     673 </span>                :            :   // Repeated field mutators -----------------------------------------
<span class="lineNum">     674 </span>                :            :   // These mutate the value of one element of a repeated field.
<span class="lineNum">     675 </span>                :            : 
<span class="lineNum">     676 </span>                :            :   virtual void SetRepeatedInt32 (Message* message,
<span class="lineNum">     677 </span>                :            :                                  const FieldDescriptor* field,
<span class="lineNum">     678 </span>                :            :                                  int index, int32  value) const = 0;
<span class="lineNum">     679 </span>                :            :   virtual void SetRepeatedInt64 (Message* message,
<span class="lineNum">     680 </span>                :            :                                  const FieldDescriptor* field,
<span class="lineNum">     681 </span>                :            :                                  int index, int64  value) const = 0;
<span class="lineNum">     682 </span>                :            :   virtual void SetRepeatedUInt32(Message* message,
<span class="lineNum">     683 </span>                :            :                                  const FieldDescriptor* field,
<span class="lineNum">     684 </span>                :            :                                  int index, uint32 value) const = 0;
<span class="lineNum">     685 </span>                :            :   virtual void SetRepeatedUInt64(Message* message,
<span class="lineNum">     686 </span>                :            :                                  const FieldDescriptor* field,
<span class="lineNum">     687 </span>                :            :                                  int index, uint64 value) const = 0;
<span class="lineNum">     688 </span>                :            :   virtual void SetRepeatedFloat (Message* message,
<span class="lineNum">     689 </span>                :            :                                  const FieldDescriptor* field,
<span class="lineNum">     690 </span>                :            :                                  int index, float  value) const = 0;
<span class="lineNum">     691 </span>                :            :   virtual void SetRepeatedDouble(Message* message,
<span class="lineNum">     692 </span>                :            :                                  const FieldDescriptor* field,
<span class="lineNum">     693 </span>                :            :                                  int index, double value) const = 0;
<span class="lineNum">     694 </span>                :            :   virtual void SetRepeatedBool  (Message* message,
<span class="lineNum">     695 </span>                :            :                                  const FieldDescriptor* field,
<span class="lineNum">     696 </span>                :            :                                  int index, bool   value) const = 0;
<span class="lineNum">     697 </span>                :            :   virtual void SetRepeatedString(Message* message,
<span class="lineNum">     698 </span>                :            :                                  const FieldDescriptor* field,
<span class="lineNum">     699 </span>                :            :                                  int index, const string&amp; value) const = 0;
<span class="lineNum">     700 </span>                :            :   virtual void SetRepeatedEnum(Message* message,
<span class="lineNum">     701 </span>                :            :                                const FieldDescriptor* field, int index,
<span class="lineNum">     702 </span>                :            :                                const EnumValueDescriptor* value) const = 0;
<span class="lineNum">     703 </span>                :            :   // Set an enum field's value with an integer rather than EnumValueDescriptor.
<span class="lineNum">     704 </span>                :            :   // If the value does not correspond to a known enum value, either behavior is
<span class="lineNum">     705 </span>                :            :   // undefined (for proto2 messages), or the value is accepted silently for
<span class="lineNum">     706 </span>                :            :   // messages with new unknown-enum-value semantics.
<span class="lineNum">     707 </span>                :            :   virtual void SetRepeatedEnumValue(Message* message,
<span class="lineNum">     708 </span>                :            :                                     const FieldDescriptor* field, int index,
<span class="lineNum">     709 </span>                :            :                                     int value) const = 0;
<span class="lineNum">     710 </span>                :            :   // Get a mutable pointer to an element of a repeated field with a message
<span class="lineNum">     711 </span>                :            :   // type.
<span class="lineNum">     712 </span>                :            :   virtual Message* MutableRepeatedMessage(
<span class="lineNum">     713 </span>                :            :       Message* message, const FieldDescriptor* field, int index) const = 0;
<span class="lineNum">     714 </span>                :            : 
<span class="lineNum">     715 </span>                :            : 
<span class="lineNum">     716 </span>                :            :   // Repeated field adders -------------------------------------------
<span class="lineNum">     717 </span>                :            :   // These add an element to a repeated field.
<span class="lineNum">     718 </span>                :            : 
<span class="lineNum">     719 </span>                :            :   virtual void AddInt32 (Message* message,
<span class="lineNum">     720 </span>                :            :                          const FieldDescriptor* field, int32  value) const = 0;
<span class="lineNum">     721 </span>                :            :   virtual void AddInt64 (Message* message,
<span class="lineNum">     722 </span>                :            :                          const FieldDescriptor* field, int64  value) const = 0;
<span class="lineNum">     723 </span>                :            :   virtual void AddUInt32(Message* message,
<span class="lineNum">     724 </span>                :            :                          const FieldDescriptor* field, uint32 value) const = 0;
<span class="lineNum">     725 </span>                :            :   virtual void AddUInt64(Message* message,
<span class="lineNum">     726 </span>                :            :                          const FieldDescriptor* field, uint64 value) const = 0;
<span class="lineNum">     727 </span>                :            :   virtual void AddFloat (Message* message,
<span class="lineNum">     728 </span>                :            :                          const FieldDescriptor* field, float  value) const = 0;
<span class="lineNum">     729 </span>                :            :   virtual void AddDouble(Message* message,
<span class="lineNum">     730 </span>                :            :                          const FieldDescriptor* field, double value) const = 0;
<span class="lineNum">     731 </span>                :            :   virtual void AddBool  (Message* message,
<span class="lineNum">     732 </span>                :            :                          const FieldDescriptor* field, bool   value) const = 0;
<span class="lineNum">     733 </span>                :            :   virtual void AddString(Message* message,
<span class="lineNum">     734 </span>                :            :                          const FieldDescriptor* field,
<span class="lineNum">     735 </span>                :            :                          const string&amp; value) const = 0;
<span class="lineNum">     736 </span>                :            :   virtual void AddEnum  (Message* message,
<span class="lineNum">     737 </span>                :            :                          const FieldDescriptor* field,
<span class="lineNum">     738 </span>                :            :                          const EnumValueDescriptor* value) const = 0;
<span class="lineNum">     739 </span>                :            :   // Set an enum field's value with an integer rather than EnumValueDescriptor.
<span class="lineNum">     740 </span>                :            :   // If the value does not correspond to a known enum value, either behavior is
<span class="lineNum">     741 </span>                :            :   // undefined (for proto2 messages), or the value is accepted silently for
<span class="lineNum">     742 </span>                :            :   // messages with new unknown-enum-value semantics.
<span class="lineNum">     743 </span>                :            :   virtual void AddEnumValue(Message* message,
<span class="lineNum">     744 </span>                :            :                             const FieldDescriptor* field,
<span class="lineNum">     745 </span>                :            :                             int value) const = 0;
<span class="lineNum">     746 </span>                :            :   // See MutableMessage() for comments on the &quot;factory&quot; parameter.
<span class="lineNum">     747 </span>                :            :   virtual Message* AddMessage(Message* message,
<span class="lineNum">     748 </span>                :            :                               const FieldDescriptor* field,
<span class="lineNum">     749 </span>                :            :                               MessageFactory* factory = NULL) const = 0;
<span class="lineNum">     750 </span>                :            : 
<span class="lineNum">     751 </span>                :            :   // Appends an already-allocated object 'new_entry' to the repeated field
<span class="lineNum">     752 </span>                :            :   // specifyed by 'field' passing ownership to the message.
<span class="lineNum">     753 </span>                :            :   // TODO(tmarek): Make virtual after all subclasses have been
<span class="lineNum">     754 </span>                :            :   // updated.
<span class="lineNum">     755 </span>                :            :   virtual void AddAllocatedMessage(Message* /* message */,
<span class="lineNum">     756 </span>                :            :                                    const FieldDescriptor* /*field */,
<span class="lineNum">     757 </span>                :            :                                    Message* /* new_entry */) const {}
<span class="lineNum">     758 </span>                :            : 
<span class="lineNum">     759 </span>                :            : 
<span class="lineNum">     760 </span>                :            :   // Get a RepeatedFieldRef object that can be used to read the underlying
<span class="lineNum">     761 </span>                :            :   // repeated field. The type parameter T must be set according to the
<span class="lineNum">     762 </span>                :            :   // field's cpp type. The following table shows the mapping from cpp type
<span class="lineNum">     763 </span>                :            :   // to acceptable T.
<span class="lineNum">     764 </span>                :            :   //
<span class="lineNum">     765 </span>                :            :   //   field-&gt;cpp_type()      T
<span class="lineNum">     766 </span>                :            :   //   CPPTYPE_INT32        int32
<span class="lineNum">     767 </span>                :            :   //   CPPTYPE_UINT32       uint32
<span class="lineNum">     768 </span>                :            :   //   CPPTYPE_INT64        int64
<span class="lineNum">     769 </span>                :            :   //   CPPTYPE_UINT64       uint64
<span class="lineNum">     770 </span>                :            :   //   CPPTYPE_DOUBLE       double
<span class="lineNum">     771 </span>                :            :   //   CPPTYPE_FLOAT        float
<span class="lineNum">     772 </span>                :            :   //   CPPTYPE_BOOL         bool
<span class="lineNum">     773 </span>                :            :   //   CPPTYPE_ENUM         generated enum type or int32
<span class="lineNum">     774 </span>                :            :   //   CPPTYPE_STRING       string
<span class="lineNum">     775 </span>                :            :   //   CPPTYPE_MESSAGE      generated message type or google::protobuf::Message
<span class="lineNum">     776 </span>                :            :   //
<span class="lineNum">     777 </span>                :            :   // A RepeatedFieldRef object can be copied and the resulted object will point
<span class="lineNum">     778 </span>                :            :   // to the same repeated field in the same message. The object can be used as
<span class="lineNum">     779 </span>                :            :   // long as the message is not destroyed.
<span class="lineNum">     780 </span>                :            :   //
<span class="lineNum">     781 </span>                :            :   // Note that to use this method users need to include the header file
<span class="lineNum">     782 </span>                :            :   // &quot;google/protobuf/reflection.h&quot; (which defines the RepeatedFieldRef
<span class="lineNum">     783 </span>                :            :   // class templates).
<span class="lineNum">     784 </span>                :            :   template&lt;typename T&gt;
<span class="lineNum">     785 </span>                :            :   RepeatedFieldRef&lt;T&gt; GetRepeatedFieldRef(
<span class="lineNum">     786 </span>                :            :       const Message&amp; message, const FieldDescriptor* field) const;
<span class="lineNum">     787 </span>                :            : 
<span class="lineNum">     788 </span>                :            :   // Like GetRepeatedFieldRef() but return an object that can also be used
<span class="lineNum">     789 </span>                :            :   // manipulate the underlying repeated field.
<span class="lineNum">     790 </span>                :            :   template&lt;typename T&gt;
<span class="lineNum">     791 </span>                :            :   MutableRepeatedFieldRef&lt;T&gt; GetMutableRepeatedFieldRef(
<span class="lineNum">     792 </span>                :            :       Message* message, const FieldDescriptor* field) const;
<span class="lineNum">     793 </span>                :            : 
<span class="lineNum">     794 </span>                :            :   // DEPRECATED. Please use Get(Mutable)RepeatedFieldRef() for repeated field
<span class="lineNum">     795 </span>                :            :   // access. The following repeated field accesors will be removed in the
<span class="lineNum">     796 </span>                :            :   // future.
<span class="lineNum">     797 </span>                :            :   //
<span class="lineNum">     798 </span>                :            :   // Repeated field accessors  -------------------------------------------------
<span class="lineNum">     799 </span>                :            :   // The methods above, e.g. GetRepeatedInt32(msg, fd, index), provide singular
<span class="lineNum">     800 </span>                :            :   // access to the data in a RepeatedField.  The methods below provide aggregate
<span class="lineNum">     801 </span>                :            :   // access by exposing the RepeatedField object itself with the Message.
<span class="lineNum">     802 </span>                :            :   // Applying these templates to inappropriate types will lead to an undefined
<span class="lineNum">     803 </span>                :            :   // reference at link time (e.g. GetRepeatedField&lt;***double&gt;), or possibly a
<span class="lineNum">     804 </span>                :            :   // template matching error at compile time (e.g. GetRepeatedPtrField&lt;File&gt;).
<span class="lineNum">     805 </span>                :            :   //
<span class="lineNum">     806 </span>                :            :   // Usage example: my_doubs = refl-&gt;GetRepeatedField&lt;double&gt;(msg, fd);
<span class="lineNum">     807 </span>                :            : 
<span class="lineNum">     808 </span>                :            :   // DEPRECATED. Please use GetRepeatedFieldRef().
<span class="lineNum">     809 </span>                :            :   //
<span class="lineNum">     810 </span>                :            :   // for T = Cord and all protobuf scalar types except enums.
<span class="lineNum">     811 </span>                :            :   template&lt;typename T&gt;
<span class="lineNum">     812 </span>                :            :   const RepeatedField&lt;T&gt;&amp; GetRepeatedField(
<span class="lineNum">     813 </span>                :            :       const Message&amp;, const FieldDescriptor*) const;
<span class="lineNum">     814 </span>                :            : 
<span class="lineNum">     815 </span>                :            :   // DEPRECATED. Please use GetMutableRepeatedFieldRef().
<span class="lineNum">     816 </span>                :            :   //
<span class="lineNum">     817 </span>                :            :   // for T = Cord and all protobuf scalar types except enums.
<span class="lineNum">     818 </span>                :            :   template&lt;typename T&gt;
<span class="lineNum">     819 </span>                :            :   RepeatedField&lt;T&gt;* MutableRepeatedField(
<span class="lineNum">     820 </span>                :            :       Message*, const FieldDescriptor*) const;
<span class="lineNum">     821 </span>                :            : 
<span class="lineNum">     822 </span>                :            :   // DEPRECATED. Please use GetRepeatedFieldRef().
<span class="lineNum">     823 </span>                :            :   //
<span class="lineNum">     824 </span>                :            :   // for T = string, google::protobuf::internal::StringPieceField
<span class="lineNum">     825 </span>                :            :   //         google::protobuf::Message &amp; descendants.
<span class="lineNum">     826 </span>                :            :   template&lt;typename T&gt;
<span class="lineNum">     827 </span>                :            :   const RepeatedPtrField&lt;T&gt;&amp; GetRepeatedPtrField(
<span class="lineNum">     828 </span>                :            :       const Message&amp;, const FieldDescriptor*) const;
<span class="lineNum">     829 </span>                :            : 
<span class="lineNum">     830 </span>                :            :   // DEPRECATED. Please use GetMutableRepeatedFieldRef().
<span class="lineNum">     831 </span>                :            :   //
<span class="lineNum">     832 </span>                :            :   // for T = string, google::protobuf::internal::StringPieceField
<span class="lineNum">     833 </span>                :            :   //         google::protobuf::Message &amp; descendants.
<span class="lineNum">     834 </span>                :            :   template&lt;typename T&gt;
<span class="lineNum">     835 </span>                :            :   RepeatedPtrField&lt;T&gt;* MutableRepeatedPtrField(
<span class="lineNum">     836 </span>                :            :       Message*, const FieldDescriptor*) const;
<span class="lineNum">     837 </span>                :            : 
<span class="lineNum">     838 </span>                :            :   // Extensions ----------------------------------------------------------------
<span class="lineNum">     839 </span>                :            : 
<span class="lineNum">     840 </span>                :            :   // Try to find an extension of this message type by fully-qualified field
<span class="lineNum">     841 </span>                :            :   // name.  Returns NULL if no extension is known for this name or number.
<span class="lineNum">     842 </span>                :            :   virtual const FieldDescriptor* FindKnownExtensionByName(
<span class="lineNum">     843 </span>                :            :       const string&amp; name) const = 0;
<span class="lineNum">     844 </span>                :            : 
<span class="lineNum">     845 </span>                :            :   // Try to find an extension of this message type by field number.
<span class="lineNum">     846 </span>                :            :   // Returns NULL if no extension is known for this name or number.
<span class="lineNum">     847 </span>                :            :   virtual const FieldDescriptor* FindKnownExtensionByNumber(
<span class="lineNum">     848 </span>                :            :       int number) const = 0;
<span class="lineNum">     849 </span>                :            : 
<span class="lineNum">     850 </span>                :            :   // Feature Flags -------------------------------------------------------------
<span class="lineNum">     851 </span>                :            : 
<span class="lineNum">     852 </span>                :            :   // Does this message support storing arbitrary integer values in enum fields?
<span class="lineNum">     853 </span>                :            :   // If |true|, GetEnumValue/SetEnumValue and associated repeated-field versions
<span class="lineNum">     854 </span>                :            :   // take arbitrary integer values, and the legacy GetEnum() getter will
<span class="lineNum">     855 </span>                :            :   // dynamically create an EnumValueDescriptor for any integer value without
<span class="lineNum">     856 </span>                :            :   // one. If |false|, setting an unknown enum value via the integer-based
<span class="lineNum">     857 </span>                :            :   // setters results in undefined behavior (in practice, GOOGLE_DCHECK-fails).
<span class="lineNum">     858 </span>                :            :   //
<span class="lineNum">     859 </span>                :            :   // Generic code that uses reflection to handle messages with enum fields
<span class="lineNum">     860 </span>                :            :   // should check this flag before using the integer-based setter, and either
<span class="lineNum">     861 </span>                :            :   // downgrade to a compatible value or use the UnknownFieldSet if not. For
<span class="lineNum">     862 </span>                :            :   // example:
<span class="lineNum">     863 </span>                :            :   //
<span class="lineNum">     864 </span>                :            :   //   int new_value = GetValueFromApplicationLogic();
<span class="lineNum">     865 </span>                :            :   //   if (reflection-&gt;SupportsUnknownEnumValues()) {
<span class="lineNum">     866 </span>                :            :   //     reflection-&gt;SetEnumValue(message, field, new_value);
<span class="lineNum">     867 </span>                :            :   //   } else {
<span class="lineNum">     868 </span>                :            :   //     if (field_descriptor-&gt;enum_type()-&gt;
<span class="lineNum">     869 </span>                :            :   //             FindValueByNumber(new_value) != NULL) {
<span class="lineNum">     870 </span>                :            :   //       reflection-&gt;SetEnumValue(message, field, new_value);
<span class="lineNum">     871 </span>                :            :   //     } else if (emit_unknown_enum_values) {
<span class="lineNum">     872 </span>                :            :   //       reflection-&gt;MutableUnknownFields(message)-&gt;AddVarint(
<span class="lineNum">     873 </span>                :            :   //           field-&gt;number(), new_value);
<span class="lineNum">     874 </span>                :            :   //     } else {
<span class="lineNum">     875 </span>                :            :   //       // convert value to a compatible/default value.
<span class="lineNum">     876 </span>                :            :   //       new_value = CompatibleDowngrade(new_value);
<span class="lineNum">     877 </span>                :            :   //       reflection-&gt;SetEnumValue(message, field, new_value);
<span class="lineNum">     878 </span>                :            :   //     }
<span class="lineNum">     879 </span>                :            :   //   }
<span class="lineNum">     880 </span>                :            :   virtual bool SupportsUnknownEnumValues() const { return false; }
<span class="lineNum">     881 </span>                :            : 
<span class="lineNum">     882 </span>                :            :   // Returns the MessageFactory associated with this message.  This can be
<span class="lineNum">     883 </span>                :            :   // useful for determining if a message is a generated message or not, for
<span class="lineNum">     884 </span>                :            :   // example:
<span class="lineNum">     885 </span>                :            :   //   if (message-&gt;GetReflection()-&gt;GetMessageFactory() ==
<span class="lineNum">     886 </span>                :            :   //       google::protobuf::MessageFactory::generated_factory()) {
<span class="lineNum">     887 </span>                :            :   //     // This is a generated message.
<span class="lineNum">     888 </span>                :            :   //   }
<span class="lineNum">     889 </span>                :            :   // It can also be used to create more messages of this type, though
<span class="lineNum">     890 </span>                :            :   // Message::New() is an easier way to accomplish this.
<span class="lineNum">     891 </span>                :            :   virtual MessageFactory* GetMessageFactory() const;
<span class="lineNum">     892 </span>                :            : 
<span class="lineNum">     893 </span>                :            :   // ---------------------------------------------------------------------------
<span class="lineNum">     894 </span>                :            : 
<span class="lineNum">     895 </span>                :            :  protected:
<span class="lineNum">     896 </span>                :            :   // Obtain a pointer to a Repeated Field Structure and do some type checking:
<span class="lineNum">     897 </span>                :            :   //   on field-&gt;cpp_type(),
<span class="lineNum">     898 </span>                :            :   //   on field-&gt;field_option().ctype() (if ctype &gt;= 0)
<span class="lineNum">     899 </span>                :            :   //   of field-&gt;message_type() (if message_type != NULL).
<span class="lineNum">     900 </span>                :            :   // We use 2 routine rather than 4 (const vs mutable) x (scalar vs pointer).
<span class="lineNum">     901 </span>                :            :   virtual void* MutableRawRepeatedField(
<span class="lineNum">     902 </span>                :            :       Message* message, const FieldDescriptor* field, FieldDescriptor::CppType,
<span class="lineNum">     903 </span>                :            :       int ctype, const Descriptor* message_type) const = 0;
<a name="904"><span class="lineNum">     904 </span>                :            : </a>
<span class="lineNum">     905 </span>                :            :   // TODO(jieluo) - make it pure virtual after updating all the subclasses.
<span class="lineNum">     906 </span>                :<span class="lineNoCov">          0 :   virtual const void* GetRawRepeatedField(</span>
<span class="lineNum">     907 </span>                :            :       const Message&amp; message, const FieldDescriptor* field,
<span class="lineNum">     908 </span>                :            :       FieldDescriptor::CppType cpptype, int ctype,
<span class="lineNum">     909 </span>                :            :       const Descriptor* message_type) const {
<span class="lineNum">     910 </span>                :            :     return MutableRawRepeatedField(
<span class="lineNum">     911 </span>                :<span class="lineNoCov">          0 :         const_cast&lt;Message*&gt;(&amp;message), field, cpptype, ctype, message_type);</span>
<span class="lineNum">     912 </span>                :            :   }
<span class="lineNum">     913 </span>                :            : 
<span class="lineNum">     914 </span>                :            :   // The following methods are used to implement (Mutable)RepeatedFieldRef.
<span class="lineNum">     915 </span>                :            :   // A Ref object will store a raw pointer to the repeated field data (obtained
<span class="lineNum">     916 </span>                :            :   // from RepeatedFieldData()) and a pointer to a Accessor (obtained from
<span class="lineNum">     917 </span>                :            :   // RepeatedFieldAccessor) which will be used to access the raw data.
<span class="lineNum">     918 </span>                :            :   //
<span class="lineNum">     919 </span>                :            :   // TODO(xiaofeng): Make these methods pure-virtual.
<span class="lineNum">     920 </span>                :            : 
<span class="lineNum">     921 </span>                :            :   // Returns a raw pointer to the repeated field
<span class="lineNum">     922 </span>                :            :   //
<span class="lineNum">     923 </span>                :            :   // &quot;cpp_type&quot; and &quot;message_type&quot; are decuded from the type parameter T passed
<span class="lineNum">     924 </span>                :            :   // to Get(Mutable)RepeatedFieldRef. If T is a generated message type,
<span class="lineNum">     925 </span>                :            :   // &quot;message_type&quot; should be set to its descriptor. Otherwise &quot;message_type&quot;
<span class="lineNum">     926 </span>                :            :   // should be set to NULL. Implementations of this method should check whether
<span class="lineNum">     927 </span>                :            :   // &quot;cpp_type&quot;/&quot;message_type&quot; is consistent with the actual type of the field.
<span class="lineNum">     928 </span>                :            :   // We use 1 routine rather than 2 (const vs mutable) because it is protected
<span class="lineNum">     929 </span>                :            :   // and it doesn't change the message.
<span class="lineNum">     930 </span>                :            :   virtual void* RepeatedFieldData(
<span class="lineNum">     931 </span>                :            :       Message* message, const FieldDescriptor* field,
<span class="lineNum">     932 </span>                :            :       FieldDescriptor::CppType cpp_type,
<span class="lineNum">     933 </span>                :            :       const Descriptor* message_type) const;
<span class="lineNum">     934 </span>                :            : 
<span class="lineNum">     935 </span>                :            :   // The returned pointer should point to a singleton instance which implements
<span class="lineNum">     936 </span>                :            :   // the RepeatedFieldAccessor interface.
<span class="lineNum">     937 </span>                :            :   virtual const internal::RepeatedFieldAccessor* RepeatedFieldAccessor(
<span class="lineNum">     938 </span>                :            :       const FieldDescriptor* field) const;
<span class="lineNum">     939 </span>                :            : 
<span class="lineNum">     940 </span>                :            :  private:
<span class="lineNum">     941 </span>                :            :   template&lt;typename T, typename Enable&gt;
<span class="lineNum">     942 </span>                :            :   friend class RepeatedFieldRef;
<span class="lineNum">     943 </span>                :            :   template&lt;typename T, typename Enable&gt;
<span class="lineNum">     944 </span>                :            :   friend class MutableRepeatedFieldRef;
<span class="lineNum">     945 </span>                :            :   friend class ::google::protobuf::python::MapReflectionFriend;
<span class="lineNum">     946 </span>                :            :   friend class internal::MapFieldReflectionTest;
<span class="lineNum">     947 </span>                :            :   friend class internal::MapKeySorter;
<span class="lineNum">     948 </span>                :            :   friend class internal::WireFormat;
<span class="lineNum">     949 </span>                :            :   friend class internal::ReflectionOps;
<span class="lineNum">     950 </span>                :            : 
<span class="lineNum">     951 </span>                :            :   // Special version for specialized implementations of string.  We can't call
<span class="lineNum">     952 </span>                :            :   // MutableRawRepeatedField directly here because we don't have access to
<span class="lineNum">     953 </span>                :            :   // FieldOptions::* which are defined in descriptor.pb.h.  Including that
<span class="lineNum">     954 </span>                :            :   // file here is not possible because it would cause a circular include cycle.
<span class="lineNum">     955 </span>                :            :   // We use 1 routine rather than 2 (const vs mutable) because it is private
<span class="lineNum">     956 </span>                :            :   // and mutable a repeated string field doesn't change the message.
<span class="lineNum">     957 </span>                :            :   void* MutableRawRepeatedString(
<span class="lineNum">     958 </span>                :            :       Message* message, const FieldDescriptor* field, bool is_string) const;
<span class="lineNum">     959 </span>                :            : 
<span class="lineNum">     960 </span>                :            :   friend class MapReflectionTester;
<span class="lineNum">     961 </span>                :            :   // TODO(jieluo) - make the map APIs pure virtual after updating
<span class="lineNum">     962 </span>                :            :   // all the subclasses.
<span class="lineNum">     963 </span>                :            :   // Returns true if key is in map. Returns false if key is not in map field.
<span class="lineNum">     964 </span>                :            :   virtual bool ContainsMapKey(const Message&amp; /* message*/,
<span class="lineNum">     965 </span>                :            :                               const FieldDescriptor* /* field */,
<span class="lineNum">     966 </span>                :            :                               const MapKey&amp; /* key */) const {
<span class="lineNum">     967 </span>                :            :     return false;
<span class="lineNum">     968 </span>                :            :   }
<span class="lineNum">     969 </span>                :            : 
<span class="lineNum">     970 </span>                :            :   // If key is in map field: Saves the value pointer to val and returns
<span class="lineNum">     971 </span>                :            :   // false. If key in not in map field: Insert the key into map, saves
<span class="lineNum">     972 </span>                :            :   // value pointer to val and retuns true.
<span class="lineNum">     973 </span>                :            :   virtual bool InsertOrLookupMapValue(Message* /* message */,
<span class="lineNum">     974 </span>                :            :                                       const FieldDescriptor* /* field */,
<span class="lineNum">     975 </span>                :            :                                       const MapKey&amp; /* key */,
<span class="lineNum">     976 </span>                :            :                                       MapValueRef* /* val */) const {
<span class="lineNum">     977 </span>                :            :     return false;
<span class="lineNum">     978 </span>                :            :   }
<span class="lineNum">     979 </span>                :            : 
<span class="lineNum">     980 </span>                :            :   // Delete and returns true if key is in the map field. Returns false
<span class="lineNum">     981 </span>                :            :   // otherwise.
<span class="lineNum">     982 </span>                :            :   virtual bool DeleteMapValue(Message* /* mesage */,
<span class="lineNum">     983 </span>                :            :                               const FieldDescriptor* /* field */,
<span class="lineNum">     984 </span>                :            :                               const MapKey&amp; /* key */) const {
<span class="lineNum">     985 </span>                :            :     return false;
<span class="lineNum">     986 </span>                :            :   }
<span class="lineNum">     987 </span>                :            : 
<span class="lineNum">     988 </span>                :            :   // Returns a MapIterator referring to the first element in the map field.
<span class="lineNum">     989 </span>                :            :   // If the map field is empty, this function returns the same as
<span class="lineNum">     990 </span>                :            :   // reflection::MapEnd. Mutation to the field may invalidate the iterator.
<span class="lineNum">     991 </span>                :            :   virtual MapIterator MapBegin(
<span class="lineNum">     992 </span>                :            :       Message* message,
<span class="lineNum">     993 </span>                :            :       const FieldDescriptor* field) const;
<span class="lineNum">     994 </span>                :            : 
<span class="lineNum">     995 </span>                :            :   // Returns a MapIterator referring to the theoretical element that would
<span class="lineNum">     996 </span>                :            :   // follow the last element in the map field. It does not point to any
<span class="lineNum">     997 </span>                :            :   // real element. Mutation to the field may invalidate the iterator.
<span class="lineNum">     998 </span>                :            :   virtual MapIterator MapEnd(
<span class="lineNum">     999 </span>                :            :       Message* message,
<span class="lineNum">    1000 </span>                :            :       const FieldDescriptor* field) const;
<span class="lineNum">    1001 </span>                :            : 
<span class="lineNum">    1002 </span>                :            :   // Get the number of &lt;key, value&gt; pair of a map field. The result may be
<span class="lineNum">    1003 </span>                :            :   // different from FieldSize which can have duplicate keys.
<span class="lineNum">    1004 </span>                :            :   virtual int MapSize(const Message&amp; /* message */,
<span class="lineNum">    1005 </span>                :            :                       const FieldDescriptor* /* field */) const {
<span class="lineNum">    1006 </span>                :            :     return 0;
<span class="lineNum">    1007 </span>                :            :   }
<span class="lineNum">    1008 </span>                :            : 
<span class="lineNum">    1009 </span>                :            :   // Help method for MapIterator.
<span class="lineNum">    1010 </span>                :            :   friend class MapIterator;
<span class="lineNum">    1011 </span>                :            :   virtual internal::MapFieldBase* MapData(
<span class="lineNum">    1012 </span>                :            :       Message* /* message */, const FieldDescriptor* /* field */) const {
<span class="lineNum">    1013 </span>                :            :     return NULL;
<span class="lineNum">    1014 </span>                :            :   }
<span class="lineNum">    1015 </span>                :            : 
<span class="lineNum">    1016 </span>                :            :   GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(Reflection);
<span class="lineNum">    1017 </span>                :            : };
<span class="lineNum">    1018 </span>                :            : 
<span class="lineNum">    1019 </span>                :            : // Abstract interface for a factory for message objects.
<span class="lineNum">    1020 </span>                :            : class LIBPROTOBUF_EXPORT MessageFactory {
<span class="lineNum">    1021 </span>                :            :  public:
<span class="lineNum">    1022 </span>                :            :   inline MessageFactory() {}
<span class="lineNum">    1023 </span>                :            :   virtual ~MessageFactory();
<span class="lineNum">    1024 </span>                :            : 
<span class="lineNum">    1025 </span>                :            :   // Given a Descriptor, gets or constructs the default (prototype) Message
<span class="lineNum">    1026 </span>                :            :   // of that type.  You can then call that message's New() method to construct
<span class="lineNum">    1027 </span>                :            :   // a mutable message of that type.
<span class="lineNum">    1028 </span>                :            :   //
<span class="lineNum">    1029 </span>                :            :   // Calling this method twice with the same Descriptor returns the same
<span class="lineNum">    1030 </span>                :            :   // object.  The returned object remains property of the factory.  Also, any
<span class="lineNum">    1031 </span>                :            :   // objects created by calling the prototype's New() method share some data
<span class="lineNum">    1032 </span>                :            :   // with the prototype, so these must be destroyed before the MessageFactory
<span class="lineNum">    1033 </span>                :            :   // is destroyed.
<span class="lineNum">    1034 </span>                :            :   //
<span class="lineNum">    1035 </span>                :            :   // The given descriptor must outlive the returned message, and hence must
<span class="lineNum">    1036 </span>                :            :   // outlive the MessageFactory.
<span class="lineNum">    1037 </span>                :            :   //
<span class="lineNum">    1038 </span>                :            :   // Some implementations do not support all types.  GetPrototype() will
<span class="lineNum">    1039 </span>                :            :   // return NULL if the descriptor passed in is not supported.
<span class="lineNum">    1040 </span>                :            :   //
<span class="lineNum">    1041 </span>                :            :   // This method may or may not be thread-safe depending on the implementation.
<span class="lineNum">    1042 </span>                :            :   // Each implementation should document its own degree thread-safety.
<span class="lineNum">    1043 </span>                :            :   virtual const Message* GetPrototype(const Descriptor* type) = 0;
<span class="lineNum">    1044 </span>                :            : 
<span class="lineNum">    1045 </span>                :            :   // Gets a MessageFactory which supports all generated, compiled-in messages.
<span class="lineNum">    1046 </span>                :            :   // In other words, for any compiled-in type FooMessage, the following is true:
<span class="lineNum">    1047 </span>                :            :   //   MessageFactory::generated_factory()-&gt;GetPrototype(
<span class="lineNum">    1048 </span>                :            :   //     FooMessage::descriptor()) == FooMessage::default_instance()
<span class="lineNum">    1049 </span>                :            :   // This factory supports all types which are found in
<span class="lineNum">    1050 </span>                :            :   // DescriptorPool::generated_pool().  If given a descriptor from any other
<span class="lineNum">    1051 </span>                :            :   // pool, GetPrototype() will return NULL.  (You can also check if a
<span class="lineNum">    1052 </span>                :            :   // descriptor is for a generated message by checking if
<span class="lineNum">    1053 </span>                :            :   // descriptor-&gt;file()-&gt;pool() == DescriptorPool::generated_pool().)
<span class="lineNum">    1054 </span>                :            :   //
<span class="lineNum">    1055 </span>                :            :   // This factory is 100% thread-safe; calling GetPrototype() does not modify
<span class="lineNum">    1056 </span>                :            :   // any shared data.
<span class="lineNum">    1057 </span>                :            :   //
<span class="lineNum">    1058 </span>                :            :   // This factory is a singleton.  The caller must not delete the object.
<span class="lineNum">    1059 </span>                :            :   static MessageFactory* generated_factory();
<span class="lineNum">    1060 </span>                :            : 
<span class="lineNum">    1061 </span>                :            :   // For internal use only:  Registers a .proto file at static initialization
<span class="lineNum">    1062 </span>                :            :   // time, to be placed in generated_factory.  The first time GetPrototype()
<span class="lineNum">    1063 </span>                :            :   // is called with a descriptor from this file, |register_messages| will be
<span class="lineNum">    1064 </span>                :            :   // called, with the file name as the parameter.  It must call
<span class="lineNum">    1065 </span>                :            :   // InternalRegisterGeneratedMessage() (below) to register each message type
<span class="lineNum">    1066 </span>                :            :   // in the file.  This strange mechanism is necessary because descriptors are
<span class="lineNum">    1067 </span>                :            :   // built lazily, so we can't register types by their descriptor until we
<span class="lineNum">    1068 </span>                :            :   // know that the descriptor exists.  |filename| must be a permanent string.
<span class="lineNum">    1069 </span>                :            :   static void InternalRegisterGeneratedFile(
<span class="lineNum">    1070 </span>                :            :       const char* filename, void (*register_messages)(const string&amp;));
<span class="lineNum">    1071 </span>                :            : 
<span class="lineNum">    1072 </span>                :            :   // For internal use only:  Registers a message type.  Called only by the
<span class="lineNum">    1073 </span>                :            :   // functions which are registered with InternalRegisterGeneratedFile(),
<span class="lineNum">    1074 </span>                :            :   // above.
<span class="lineNum">    1075 </span>                :            :   static void InternalRegisterGeneratedMessage(const Descriptor* descriptor,
<span class="lineNum">    1076 </span>                :            :                                                const Message* prototype);
<span class="lineNum">    1077 </span>                :            : 
<span class="lineNum">    1078 </span>                :            : 
<span class="lineNum">    1079 </span>                :            :  private:
<span class="lineNum">    1080 </span>                :            :   GOOGLE_DISALLOW_EVIL_CONSTRUCTORS(MessageFactory);
<span class="lineNum">    1081 </span>                :            : };
<span class="lineNum">    1082 </span>                :            : 
<span class="lineNum">    1083 </span>                :            : #define DECLARE_GET_REPEATED_FIELD(TYPE)                         \
<span class="lineNum">    1084 </span>                :            : template&lt;&gt;                                                       \
<span class="lineNum">    1085 </span>                :            : LIBPROTOBUF_EXPORT                                               \
<span class="lineNum">    1086 </span>                :            : const RepeatedField&lt;TYPE&gt;&amp; Reflection::GetRepeatedField&lt;TYPE&gt;(   \
<span class="lineNum">    1087 </span>                :            :     const Message&amp; message, const FieldDescriptor* field) const; \
<span class="lineNum">    1088 </span>                :            :                                                                  \
<span class="lineNum">    1089 </span>                :            : template&lt;&gt;                                                       \
<span class="lineNum">    1090 </span>                :            : LIBPROTOBUF_EXPORT                                               \
<span class="lineNum">    1091 </span>                :            : RepeatedField&lt;TYPE&gt;* Reflection::MutableRepeatedField&lt;TYPE&gt;(     \
<span class="lineNum">    1092 </span>                :            :     Message* message, const FieldDescriptor* field) const;
<span class="lineNum">    1093 </span>                :            : 
<span class="lineNum">    1094 </span>                :            : DECLARE_GET_REPEATED_FIELD(int32)
<span class="lineNum">    1095 </span>                :            : DECLARE_GET_REPEATED_FIELD(int64)
<span class="lineNum">    1096 </span>                :            : DECLARE_GET_REPEATED_FIELD(uint32)
<span class="lineNum">    1097 </span>                :            : DECLARE_GET_REPEATED_FIELD(uint64)
<span class="lineNum">    1098 </span>                :            : DECLARE_GET_REPEATED_FIELD(float)
<span class="lineNum">    1099 </span>                :            : DECLARE_GET_REPEATED_FIELD(double)
<span class="lineNum">    1100 </span>                :            : DECLARE_GET_REPEATED_FIELD(bool)
<span class="lineNum">    1101 </span>                :            : 
<span class="lineNum">    1102 </span>                :            : #undef DECLARE_GET_REPEATED_FIELD
<span class="lineNum">    1103 </span>                :            : 
<span class="lineNum">    1104 </span>                :            : // =============================================================================
<span class="lineNum">    1105 </span>                :            : // Implementation details for {Get,Mutable}RawRepeatedPtrField.  We provide
<span class="lineNum">    1106 </span>                :            : // specializations for &lt;string&gt;, &lt;StringPieceField&gt; and &lt;Message&gt; and handle
<span class="lineNum">    1107 </span>                :            : // everything else with the default template which will match any type having
<span class="lineNum">    1108 </span>                :            : // a method with signature &quot;static const google::protobuf::Descriptor* descriptor()&quot;.
<span class="lineNum">    1109 </span>                :            : // Such a type presumably is a descendant of google::protobuf::Message.
<span class="lineNum">    1110 </span>                :            : 
<span class="lineNum">    1111 </span>                :            : template&lt;&gt;
<span class="lineNum">    1112 </span>                :            : inline const RepeatedPtrField&lt;string&gt;&amp; Reflection::GetRepeatedPtrField&lt;string&gt;(
<span class="lineNum">    1113 </span>                :            :     const Message&amp; message, const FieldDescriptor* field) const {
<span class="lineNum">    1114 </span>                :            :   return *static_cast&lt;RepeatedPtrField&lt;string&gt;* &gt;(
<span class="lineNum">    1115 </span>                :            :       MutableRawRepeatedString(const_cast&lt;Message*&gt;(&amp;message), field, true));
<span class="lineNum">    1116 </span>                :            : }
<span class="lineNum">    1117 </span>                :            : 
<span class="lineNum">    1118 </span>                :            : template&lt;&gt;
<span class="lineNum">    1119 </span>                :            : inline RepeatedPtrField&lt;string&gt;* Reflection::MutableRepeatedPtrField&lt;string&gt;(
<span class="lineNum">    1120 </span>                :            :     Message* message, const FieldDescriptor* field) const {
<span class="lineNum">    1121 </span>                :            :   return static_cast&lt;RepeatedPtrField&lt;string&gt;* &gt;(
<span class="lineNum">    1122 </span>                :            :       MutableRawRepeatedString(message, field, true));
<span class="lineNum">    1123 </span>                :            : }
<span class="lineNum">    1124 </span>                :            : 
<span class="lineNum">    1125 </span>                :            : 
<span class="lineNum">    1126 </span>                :            : // -----
<span class="lineNum">    1127 </span>                :            : 
<span class="lineNum">    1128 </span>                :            : template&lt;&gt;
<span class="lineNum">    1129 </span>                :            : inline const RepeatedPtrField&lt;Message&gt;&amp; Reflection::GetRepeatedPtrField(
<span class="lineNum">    1130 </span>                :            :     const Message&amp; message, const FieldDescriptor* field) const {
<span class="lineNum">    1131 </span>                :            :   return *static_cast&lt;const RepeatedPtrField&lt;Message&gt;* &gt;(
<span class="lineNum">    1132 </span>                :            :       GetRawRepeatedField(message, field, FieldDescriptor::CPPTYPE_MESSAGE,
<span class="lineNum">    1133 </span>                :            :                           -1, NULL));
<span class="lineNum">    1134 </span>                :            : }
<span class="lineNum">    1135 </span>                :            : 
<span class="lineNum">    1136 </span>                :            : template&lt;&gt;
<span class="lineNum">    1137 </span>                :            : inline RepeatedPtrField&lt;Message&gt;* Reflection::MutableRepeatedPtrField(
<span class="lineNum">    1138 </span>                :            :     Message* message, const FieldDescriptor* field) const {
<span class="lineNum">    1139 </span>                :            :   return static_cast&lt;RepeatedPtrField&lt;Message&gt;* &gt;(
<span class="lineNum">    1140 </span>                :            :       MutableRawRepeatedField(message, field,
<span class="lineNum">    1141 </span>                :            :           FieldDescriptor::CPPTYPE_MESSAGE, -1,
<span class="lineNum">    1142 </span>                :            :           NULL));
<span class="lineNum">    1143 </span>                :            : }
<span class="lineNum">    1144 </span>                :            : 
<span class="lineNum">    1145 </span>                :            : template&lt;typename PB&gt;
<span class="lineNum">    1146 </span>                :            : inline const RepeatedPtrField&lt;PB&gt;&amp; Reflection::GetRepeatedPtrField(
<span class="lineNum">    1147 </span>                :            :     const Message&amp; message, const FieldDescriptor* field) const {
<span class="lineNum">    1148 </span>                :            :   return *static_cast&lt;const RepeatedPtrField&lt;PB&gt;* &gt;(
<span class="lineNum">    1149 </span>                :            :       GetRawRepeatedField(message, field, FieldDescriptor::CPPTYPE_MESSAGE,
<span class="lineNum">    1150 </span>                :            :                           -1, PB::default_instance().GetDescriptor()));
<span class="lineNum">    1151 </span>                :            : }
<span class="lineNum">    1152 </span>                :            : 
<span class="lineNum">    1153 </span>                :            : template&lt;typename PB&gt;
<span class="lineNum">    1154 </span>                :            : inline RepeatedPtrField&lt;PB&gt;* Reflection::MutableRepeatedPtrField(
<span class="lineNum">    1155 </span>                :            :     Message* message, const FieldDescriptor* field) const {
<span class="lineNum">    1156 </span>                :            :   return static_cast&lt;RepeatedPtrField&lt;PB&gt;* &gt;(
<span class="lineNum">    1157 </span>                :            :       MutableRawRepeatedField(message, field,
<span class="lineNum">    1158 </span>                :            :           FieldDescriptor::CPPTYPE_MESSAGE, -1,
<span class="lineNum">    1159 </span>                :            :           PB::default_instance().GetDescriptor()));
<span class="lineNum">    1160 </span>                :            : }
<span class="lineNum">    1161 </span>                :            : }  // namespace protobuf
<span class="lineNum">    1162 </span>                :            : 
<span class="lineNum">    1163 </span>                :            : }  // namespace google
<span class="lineNum">    1164 </span>                :            : #endif  // GOOGLE_PROTOBUF_MESSAGE_H__
</pre>
      </td>
    </tr>
  </table>
  <br>

  <table width="100%" border=0 cellspacing=0 cellpadding=0>
    <tr><td class="ruler"><img src="../../../../../glass.png" width=3 height=3 alt=""></td></tr>
    <tr><td class="versionInfo">Generated by: <a href="http://ltp.sourceforge.net/coverage/lcov.php" target="_parent">LCOV version 1.13</a></td></tr>
  </table>
  <br>

</body>
</html>
